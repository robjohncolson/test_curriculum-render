<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AP Stats Consensus Quiz</title>
    
    <link rel="stylesheet" href="css/styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="supabase_config.js"></script>
    <script src="railway_config.js"></script>
    <script src="js/charts.js"></script>
    <script src="sync_diagnostics.js"></script>
    <script src="railway_client.js"></script>

</head>
<body>
    <canvas id="spriteCanvas"></canvas>
    <div class="container">
        <h1>🧮 AP Statistics Consensus Quiz</h1>
        <div id="messageArea"></div>
        <div id="questionsContainer"></div>
    </div>

    <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">🌙</button>
    <button class="sync-button" onclick="showSyncModal()" title="Sync & Export Data">⚡</button>
    <button class="share-button" onclick="showShareModal()" title="Share this app">📤</button>
    <button class="sprite-config-toggle" onclick="showSpriteConfigModal()" title="Sprite settings">🎮</button>

    <!-- Global Sync Modal -->
    <div id="syncModal" class="modal" style="display: none;">
        <div class="modal-content">
            <span class="close-modal">&times;</span>
            <h2><i class="fas fa-sync"></i> Data Management</h2>
            <p>Current user: <strong id="currentUserDisplay"></strong></p>

            <div class="sync-section">
                <h3><i class="fas fa-user"></i> Student Actions</h3>
                <div id="turboModeNotice" class="turbo-mode-notice" style="display: none;">
                    <i class="fas fa-sync-alt"></i>
                    <strong>Live Sync Active!</strong>
                    <p>Your answers are being automatically synced to the cloud. Manual backups are optional.</p>
                </div>
                <div class="sync-buttons">
                    <button id="saveBtn" class="modal-btn">
                        <i class="fas fa-download"></i>
                        <span>
                            <strong>Backup My Answers</strong>
                            <small>Download your progress as a file</small>
                        </span>
                    </button>
                    <button id="openBtn" class="modal-btn">
                        <i class="fas fa-upload"></i>
                        <span>
                            <strong>Restore from File</strong>
                            <small>Import answers from a backup file</small>
                        </span>
                    </button>
                </div>
            </div>

            <div class="sync-section">
                <h3><i class="fas fa-chalkboard-teacher"></i> Teacher Actions</h3>
                <div class="sync-buttons">
                    <button id="masterExportBtn" class="modal-btn">
                        <i class="fas fa-database"></i>
                        <span>
                            <strong>Export Class Data</strong>
                            <small>Combine all students into one file</small>
                        </span>
                    </button>
                    <button id="masterImportBtn" class="modal-btn">
                        <i class="fas fa-users"></i>
                        <span>
                            <strong>Import Class Data</strong>
                            <small>Load peer answers from teacher's file</small>
                        </span>
                    </button>
                </div>
            </div>

            <div class="sync-footer">
                <small><i class="fas fa-keyboard"></i> Tip: Press Ctrl+S to quickly access sync options</small>
            </div>
        </div>
    </div>

    <!-- Share Modal -->
    <div id="shareModal" class="modal" style="display: none;">
        <div class="modal-content share-modal-content">
            <span class="close-modal" onclick="closeShareModal()">&times;</span>
            <h2>📤 Share AP Stats Consensus Quiz</h2>

            <div class="share-description">
                <p><strong>A collaborative learning platform for AP Statistics</strong></p>
                <p>Share with your classmates to see consensus responses and learn together!</p>
            </div>

            <div class="share-sections">
                <!-- Website Section -->
                <div class="share-section">
                    <h3>🌐 Visit the Website</h3>
                    <div class="share-url-container">
                        <input type="text" id="websiteUrl" class="share-url-input" value="https://robjohncolson.github.io/curriculum_render" readonly>
                        <button class="copy-btn" onclick="copyToClipboard('websiteUrl', 'Website URL')">📋 Copy</button>
                    </div>
                    <div class="qr-code-container" id="websiteQR"></div>
                    <p class="share-instruction">Scan QR code or visit the URL to access the app</p>
                </div>

                <!-- GitHub Section -->
                <div class="share-section">
                    <h3>💻 View Source Code</h3>
                    <div class="share-url-container">
                        <input type="text" id="githubUrl" class="share-url-input" value="https://github.com/robjohncolson/curriculum_render" readonly>
                        <button class="copy-btn" onclick="copyToClipboard('githubUrl', 'GitHub URL')">📋 Copy</button>
                    </div>
                    <div class="qr-code-container" id="githubQR"></div>
                    <p class="share-instruction">GitHub repository contains source code and documentation</p>
                </div>
            </div>

            <!-- Current Location Section (always shown) -->
            <div id="currentLocationSection" class="current-location-wrapper">
                <div class="share-section current-location-section">
                    <h3 id="locationTitle">📍 Current Location</h3>
                    <div class="share-url-container">
                        <input type="text" id="currentLocation" class="share-url-input" value="" readonly>
                        <button class="copy-btn" onclick="copyToClipboard('currentLocation', 'Current location')">📋 Copy</button>
                    </div>
                    <p class="share-instruction" id="locationDescription">Loading location...</p>
                    <div id="locationInfo" class="location-info" style="display: none;">
                        <!-- Dynamic content will be added here -->
                    </div>
                </div>
            </div>

            <div class="share-footer">
                <small>💡 Teachers can export master databases for class-wide analysis</small>
                <br>
                <small>Version 2.0 | Created for AP Statistics Students</small>
            </div>
        </div>
    </div>


<script src="data/curriculum.js"></script>
    <script src="data/units.js"></script>
    <script src="js/auth.js"></script>
    <script src="js/data_manager.js"></script>
    <script>

        // ========================================
        // TURBO MODE - Supabase Integration
        // ========================================

        // Initialize Supabase client (will be null if config not set)
        let supabase = null;
        let turboModeActive = false;
        let syncCheckInterval = null;
        let lastPeerDataTimestamp = null;

        // PHASE 2 OPTIMIZATION: Answer batching queue
        let answerSyncQueue = [];
        let syncTimer = null;
        const BATCH_SIZE = 10;           // Flush after 10 answers
        const BATCH_INTERVAL = 60000;    // Flush every 60 seconds

        // Initialize Supabase if credentials are provided
        if (typeof SUPABASE_URL !== 'undefined' && SUPABASE_URL !== 'YOUR_SUPABASE_PROJECT_URL' &&
            typeof SUPABASE_ANON_KEY !== 'undefined' && SUPABASE_ANON_KEY !== 'YOUR_SUPABASE_ANON_KEY') {
            try {
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log('🚀 Supabase client initialized');
            } catch (error) {
                console.log('❌ Failed to initialize Supabase:', error);
                supabase = null;
            }
        } else {
            console.log('📝 Supabase config not set - running in offline mode');
        }

        // Test Supabase connection with timeout
        async function testSupabaseConnection() {
            if (!supabase) {
                turboModeActive = false;
                window.dispatchEvent(new CustomEvent('turboModeChanged', { detail: { enabled: turboModeActive } }));
                console.log('No Supabase client available');
                return false;
            }

            try {
                // Create a promise that rejects after 2 seconds
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Connection timeout')), 2000);
                });

                // Test query - just check if we can connect
                const testQuery = supabase
                    .from('answers')
                    .select('question_id')
                    .limit(1);

                // Race between the query and timeout
                const result = await Promise.race([testQuery, timeoutPromise]);

                // Check if the query was successful
                if (result.error) {
                    console.log('Supabase test query error:', result.error);
                    turboModeActive = false;
                    window.dispatchEvent(new CustomEvent('turboModeChanged', { detail: { enabled: turboModeActive } }));
                    return false;
                }

                turboModeActive = true;
                window.dispatchEvent(new CustomEvent('turboModeChanged', { detail: { enabled: turboModeActive } }));
                console.log('✅ Turbo mode active - Supabase connected');

                return true;
            } catch (error) {
                turboModeActive = false;
                window.dispatchEvent(new CustomEvent('turboModeChanged', { detail: { enabled: turboModeActive } }));
                console.log('🔌 Turbo mode inactive - Using offline mode:', error.message);

                return false;
            }
        }

        // Push answer to Supabase
        async function pushAnswerToSupabase(username, questionId, answerValue, timestamp) {
            if (!turboModeActive || !supabase) return false;

            try {
                // Ensure timestamp is a number (Unix milliseconds)
                if (typeof timestamp === 'string') {
                    timestamp = new Date(timestamp).getTime();
                }

                // Supabase v2 upsert syntax - array of objects, onConflict as separate parameter
                const { data, error } = await supabase
                    .from('answers')
                    .upsert(
                        [{
                            username: username,
                            question_id: questionId,
                            answer_value: answerValue,
                            timestamp: timestamp
                        }],
                        { onConflict: 'username,question_id' }
                    );

                if (error) throw error;
                console.log(`✅ Synced answer for ${questionId} to cloud`);
                return true;
            } catch (error) {
                console.log(`⚠️ Failed to sync answer: ${error.message}`);
                return false;
            }
        }

        // Batch push answers to Supabase (more efficient for bulk sync)
        async function batchPushAnswersToSupabase(answerBatch) {
            if (!turboModeActive || !supabase || answerBatch.length === 0) return 0;

            try {
                // Ensure all timestamps are numbers
                const processedBatch = answerBatch.map(answer => ({
                    ...answer,
                    timestamp: typeof answer.timestamp === 'string'
                        ? new Date(answer.timestamp).getTime()
                        : answer.timestamp
                }));

                // Supabase can handle batch upserts efficiently
                const { data, error } = await supabase
                    .from('answers')
                    .upsert(processedBatch, { onConflict: 'username,question_id' });

                if (error) throw error;
                console.log(`✅ Batch synced ${processedBatch.length} answers to cloud`);
                return processedBatch.length;
            } catch (error) {
                console.log(`⚠️ Failed to batch sync: ${error.message}`);
                return 0;
            }
        }

        // PHASE 2 OPTIMIZATION: Queue management for batching answers
        function queueAnswerForSync(username, questionId, answerValue, timestamp) {
            // Add to queue
            answerSyncQueue.push({
                username: username,
                question_id: questionId,
                answer_value: answerValue,
                timestamp: timestamp
            });

            console.log(`📝 Queued answer for ${questionId} (queue size: ${answerSyncQueue.length})`);

            // Flush immediately if batch size reached
            if (answerSyncQueue.length >= BATCH_SIZE) {
                console.log(`🚀 Batch size reached (${BATCH_SIZE}), flushing queue now`);
                flushAnswerQueue();
            } else if (!syncTimer) {
                // Start timer if this is the first item
                syncTimer = setTimeout(() => {
                    console.log(`⏰ Batch interval reached (${BATCH_INTERVAL}ms), flushing queue`);
                    flushAnswerQueue();
                }, BATCH_INTERVAL);
            }
        }

        function flushAnswerQueue() {
            if (answerSyncQueue.length === 0) return;

            // Take a copy and clear the queue
            const batch = [...answerSyncQueue];
            answerSyncQueue = [];

            // Clear the timer
            if (syncTimer) {
                clearTimeout(syncTimer);
                syncTimer = null;
            }

            // Send batch to Supabase
            console.log(`🔄 Flushing ${batch.length} answers from queue...`);
            batchPushAnswersToSupabase(batch)
                .then(count => {
                    if (count > 0) {
                        console.log(`✅ Successfully flushed ${count} answers`);
                        updatePeerDataTimestamp();
                    }
                })
                .catch(error => {
                    console.error(`❌ Error flushing queue:`, error);
                    // Re-queue failed items
                    answerSyncQueue.push(...batch);
                });
        }

        // Final flush on page unload
        window.addEventListener('beforeunload', (e) => {
            if (answerSyncQueue.length > 0) {
                console.log(`🔄 Page unload: flushing ${answerSyncQueue.length} queued answers`);
                flushAnswerQueue();
                // Show message to user that we're saving
                e.returnValue = 'Saving your answers...';
            }
        });

        // Pull peer data from Supabase - OPTIMIZED for 40+ users
        async function pullPeerDataFromSupabase() {
            if (!turboModeActive || !supabase) return null;

            try {
                const currentUser = localStorage.getItem('consensusUsername');
                if (!currentUser) return null;

                // OPTIMIZATION 1: Build query with server-side filtering
                let query = supabase
                    .from('answers')
                    .select('*')
                    .neq('username', currentUser) // Filter out own answers on server
                    .order('timestamp', { ascending: false });

                // OPTIMIZATION 2: Incremental fetch - only get data newer than last sync
                if (lastPeerDataTimestamp) {
                    query = query.gt('timestamp', lastPeerDataTimestamp);
                    console.log(`🔄 Incremental sync from timestamp: ${lastPeerDataTimestamp}`);
                } else {
                    console.log(`🔄 Initial full sync (no previous timestamp)`);
                }

                const { data, error } = await query;

                if (error) throw error;

                // OPTIMIZATION 3: Early return if no new data
                if (!data || data.length === 0) {
                    console.log('✅ No new peer data (already up to date)');
                    return null;
                }

                // Convert to our local storage format
                const peerData = {};
                data.forEach(answer => {
                    // No need to filter currentUser here - already done on server
                    if (!peerData[answer.username]) {
                        peerData[answer.username] = { answers: {} };
                    }
                    peerData[answer.username].answers[answer.question_id] = {
                        value: answer.answer_value,
                        timestamp: parseInt(answer.timestamp)
                    };
                });

                // Update last peer timestamp for next incremental fetch
                const timestamps = data.map(a => parseInt(a.timestamp));
                if (timestamps.length > 0) {
                    lastPeerDataTimestamp = Math.max(...timestamps);
                    console.log(`✅ Updated last sync timestamp: ${lastPeerDataTimestamp}`);
                }

                console.log(`✅ Pulled ${data.length} NEW answers from ${Object.keys(peerData).length} users (incremental sync)`);
                return peerData;
            } catch (error) {
                console.log(`⚠️ Failed to pull peer data: ${error.message}`);
                return null;
            }
        }

        // Sync all local answers to Supabase (for initial sync - includes ALL users)
        async function syncAllLocalAnswersToSupabase() {
            if (!turboModeActive || !supabase) return false;

            try {
                // Find all answer keys in localStorage (for all users)
                const allKeys = Object.keys(localStorage);
                const answerKeys = allKeys.filter(key => key.startsWith('answers_'));

                console.log(`Found ${answerKeys.length} users with local data to sync`);

                let totalSyncCount = 0;
                let totalAnswerCount = 0;
                let userErrors = {};

                // Sync each user's answers
                for (const answerKey of answerKeys) {
                    const username = answerKey.replace('answers_', '');
                    const answers = JSON.parse(localStorage.getItem(answerKey) || '{}');
                    const answerCount = Object.keys(answers).length;

                    if (answerCount === 0) continue;

                    console.log(`Syncing ${answerCount} answers for user: ${username}`);
                    totalAnswerCount += answerCount;

                    let userSyncCount = 0;
                    let errors = [];

                    for (const [questionId, answerData] of Object.entries(answers)) {
                        const value = answerData.value || answerData;

                        // Convert timestamp to Unix milliseconds if it's a date string
                        let timestamp = answerData.timestamp || Date.now();
                        if (typeof timestamp === 'string') {
                            timestamp = new Date(timestamp).getTime();
                        }

                        if (await pushAnswerToSupabase(username, questionId, value, timestamp)) {
                            userSyncCount++;
                            totalSyncCount++;
                        } else {
                            errors.push(questionId);
                        }
                    }

                    if (errors.length > 0) {
                        userErrors[username] = errors;
                    }

                    console.log(`  → Synced ${userSyncCount}/${answerCount} for ${username}`);
                }

                if (Object.keys(userErrors).length > 0) {
                    console.log(`⚠️ Some sync errors occurred:`, userErrors);
                }

                console.log(`✅ Total: Synced ${totalSyncCount}/${totalAnswerCount} answers across ${answerKeys.length} users`);
                return totalSyncCount > 0;
            } catch (error) {
                console.log(`⚠️ Failed to sync local answers: ${error.message}`);
                return false;
            }
        }

        // Sync ALL data from classData structure (alternative data source)
        async function syncClassDataToSupabase() {
            if (!turboModeActive || !supabase) return false;

            try {
                const classData = JSON.parse(localStorage.getItem('classData') || '{}');
                if (!classData.users) {
                    console.log('No classData.users found');
                    return false;
                }

                const users = Object.keys(classData.users);
                console.log(`Found ${users.length} users in classData to sync`);

                let totalSyncCount = 0;
                let totalAnswerCount = 0;

                for (const username of users) {
                    const userData = classData.users[username];
                    if (!userData.answers) continue;

                    const answers = userData.answers;
                    const answerCount = Object.keys(answers).length;

                    if (answerCount === 0) continue;

                    console.log(`Syncing ${answerCount} answers from classData for: ${username}`);
                    totalAnswerCount += answerCount;

                    for (const [questionId, answerData] of Object.entries(answers)) {
                        const value = answerData.value || answerData;

                        // Convert timestamp to Unix milliseconds if it's a date string
                        let timestamp = answerData.timestamp || Date.now();
                        if (typeof timestamp === 'string') {
                            timestamp = new Date(timestamp).getTime();
                        }

                        if (await pushAnswerToSupabase(username, questionId, value, timestamp)) {
                            totalSyncCount++;
                        }
                    }
                }

                console.log(`✅ Synced ${totalSyncCount}/${totalAnswerCount} answers from classData`);
                return totalSyncCount > 0;
            } catch (error) {
                console.log(`⚠️ Failed to sync classData: ${error.message}`);
                return false;
            }
        }

        // Update peer data timestamp display
        function updatePeerDataTimestamp() {
            // Find or create the timestamp display element
            let timestampDisplay = document.getElementById('peerDataTimestamp');

            if (!timestampDisplay) {
                // Create the display if it doesn't exist
                const messageArea = document.getElementById('messageArea');
                if (messageArea) {
                    timestampDisplay = document.createElement('div');
                    timestampDisplay.id = 'peerDataTimestamp';
                    timestampDisplay.style.cssText = `
                        padding: 8px 12px;
                        background: var(--bg-secondary, #f5f5f5);
                        border-radius: 4px;
                        font-size: 12px;
                        color: var(--text-secondary, #666);
                        margin-bottom: 10px;
                        text-align: center;
                    `;
                    messageArea.appendChild(timestampDisplay);
                }
            }

            if (!timestampDisplay) return;

            // Determine the most recent peer data timestamp
            let mostRecentTimestamp = lastPeerDataTimestamp;

            // Check localStorage for peer data timestamps
            const allKeys = Object.keys(localStorage);
            const peerKeys = allKeys.filter(key => key.startsWith('answers_'));
            const currentUser = localStorage.getItem('consensusUsername');

            for (const key of peerKeys) {
                const username = key.replace('answers_', '');
                if (username !== currentUser) {
                    try {
                        const answers = JSON.parse(localStorage.getItem(key) || '{}');
                        for (const answerData of Object.values(answers)) {
                            const timestamp = answerData.timestamp;
                            if (timestamp && (!mostRecentTimestamp || timestamp > mostRecentTimestamp)) {
                                mostRecentTimestamp = timestamp;
                            }
                        }
                    } catch (e) {}
                }
            }

            // Format the timestamp
            if (mostRecentTimestamp) {
                const now = Date.now();
                const diff = now - mostRecentTimestamp;
                const date = new Date(mostRecentTimestamp);

                let displayText = '';
                if (diff < 60000) { // Less than 1 minute
                    displayText = 'Just now';
                } else if (diff < 3600000) { // Less than 1 hour
                    const minutes = Math.floor(diff / 60000);
                    displayText = `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
                } else if (diff < 86400000) { // Less than 1 day
                    const hours = Math.floor(diff / 3600000);
                    displayText = `${hours} hour${hours > 1 ? 's' : ''} ago`;
                } else if (diff < 172800000) { // Less than 2 days
                    displayText = `Yesterday at ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
                } else {
                    displayText = date.toLocaleDateString() + ' at ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                }

                timestampDisplay.innerHTML = `📊 Peer data current as of: <strong>${displayText}</strong>`;

                // Add turbo mode indicator if active
                if (turboModeActive) {
                    timestampDisplay.innerHTML += ' <span style="color: #27ae60;">⚡</span>';
                }
            } else {
                timestampDisplay.innerHTML = '📊 No peer data available yet';
            }
        }

        // Perform sync check (called on interval)
        async function performSyncCheck() {
            if (!turboModeActive) {
                // Try to reconnect
                if (await testSupabaseConnection()) {
                    // Connection restored, sync local data
                    await syncAllLocalAnswersToSupabase();
                }
            }

            if (turboModeActive) {
                // Pull latest peer data
                const peerData = await pullPeerDataFromSupabase();
                if (peerData) {
                    // Merge into localStorage
                    for (const [username, userData] of Object.entries(peerData)) {
                        const key = `answers_${username}`;
                        const existing = JSON.parse(localStorage.getItem(key) || '{}');

                        // Merge answers, keeping the most recent
                        for (const [questionId, answerData] of Object.entries(userData.answers)) {
                            if (!existing[questionId] ||
                                answerData.timestamp > (existing[questionId].timestamp || 0)) {
                                existing[questionId] = answerData;
                            }
                        }

                        localStorage.setItem(key, JSON.stringify(existing));
                    }

                    // Update timestamp display
                    updatePeerDataTimestamp();

                    // If we're currently viewing a question, update the peer responses
                    // TODO: Trigger re-render of current question's peer data if needed
                    // This would need to be integrated with your existing quiz rendering logic
                }
            }
        }

        // Get current question ID from the page
        function getCurrentQuestionId() {
            // This function needs to be adapted based on your current implementation
            // Look for the current question being displayed
            const urlParams = new URLSearchParams(window.location.search);
            const topic = urlParams.get('topic');
            const question = urlParams.get('question');
            if (topic && question) {
                return `${topic}-${question}`;
            }
            return null;
        }

        // Smart sync - only sync new or updated answers
        async function smartSyncWithSupabase() {
            if (!turboModeActive || !supabase) return false;

            try {
                console.log('🔄 Starting smart sync with Supabase...');

                // First, get all existing data from Supabase
                const { data: supabaseData, error } = await supabase
                    .from('answers')
                    .select('*');

                if (error) throw error;

                // Create a map of existing Supabase data for quick lookup
                const supabaseMap = {};
                supabaseData.forEach(answer => {
                    const key = `${answer.username}_${answer.question_id}`;
                    supabaseMap[key] = answer;
                });

                // Now sync all local data, checking for updates
                const allKeys = Object.keys(localStorage);
                const answerKeys = allKeys.filter(key => key.startsWith('answers_'));

                let newCount = 0;
                let updateCount = 0;
                let skipCount = 0;
                let totalCount = 0;

                for (const answerKey of answerKeys) {
                    const username = answerKey.replace('answers_', '');
                    const answers = JSON.parse(localStorage.getItem(answerKey) || '{}');

                    for (const [questionId, answerData] of Object.entries(answers)) {
                        totalCount++;
                        const value = answerData.value || answerData;

                        // Convert timestamp to Unix milliseconds if it's a date string
                        let timestamp = answerData.timestamp || Date.now();
                        if (typeof timestamp === 'string') {
                            timestamp = new Date(timestamp).getTime();
                        }

                        const key = `${username}_${questionId}`;
                        const existingAnswer = supabaseMap[key];

                        // Check if we need to sync this answer
                        if (!existingAnswer) {
                            // New answer - sync it
                            if (await pushAnswerToSupabase(username, questionId, value, timestamp)) {
                                newCount++;
                            }
                        } else if (existingAnswer.timestamp < timestamp) {
                            // Local is newer - update Supabase
                            if (await pushAnswerToSupabase(username, questionId, value, timestamp)) {
                                updateCount++;
                            }
                        } else {
                            // Supabase is current or newer - skip
                            skipCount++;
                        }
                    }
                }

                console.log(`✅ Smart sync complete:`);
                console.log(`   - ${newCount} new answers added`);
                console.log(`   - ${updateCount} answers updated`);
                console.log(`   - ${skipCount} answers already current`);
                console.log(`   - ${totalCount} total answers processed`);

                return true;
            } catch (error) {
                console.log(`⚠️ Smart sync failed: ${error.message}`);
                return false;
            }
        }

// --- START: NEW Real-Time Update Handling System ---

/**
 * Ensures the global classData object and its user structure are initialized.
 */
function ensureClassDataInitialized() {
    if (!classData || typeof classData !== 'object') classData = { users: {} };
    if (!classData.users || typeof classData.users !== 'object') classData.users = {};
}

/**
 * Merges a new peer answer into all relevant state stores (in-memory, localStorage).
 * This acts as the single source of truth for state mutation from real-time events.
 * @param {object} detail - The event detail containing the new answer data.
 * @returns {boolean} - True if the state was updated, false otherwise.
 */
function mergePeerAnswer(detail) {
    const { username, question_id, answer_value, timestamp } = detail;
    ensureClassDataInitialized();

    if (!classData.users[username]) {
        classData.users[username] = { answers: {}, reasons: {}, timestamps: {}, attempts: {} };
    }

    const existingAnswer = classData.users[username].answers[question_id];
    const existingTimestamp = classData.users[username].timestamps[question_id] || existingAnswer?.timestamp || 0;

    if (timestamp > existingTimestamp) {
        // 1. Update in-memory `classData`
        classData.users[username].answers[question_id] = { value: answer_value, timestamp: timestamp };
        classData.users[username].timestamps[question_id] = timestamp;
        saveClassData(); // Persists the whole classData object

        // 2. Update legacy `answers_[username]` key for backward compatibility
        const legacyKey = `answers_${username}`;
        const legacyAnswers = JSON.parse(localStorage.getItem(legacyKey) || '{}');
        legacyAnswers[question_id] = { value: answer_value, timestamp: timestamp };
        localStorage.setItem(legacyKey, JSON.stringify(legacyAnswers));

        console.log(`[State Update] Merged new answer for ${username} on ${question_id}`);
        return true;
    }

    console.log(`[State Update] Ignored stale answer for ${username} on ${question_id}`);
    return false;
}

/**
 * Refreshes the UI for a specific question ID, but only if it's currently rendered.
 * @param {string} questionId The ID of the question to potentially refresh.
 */
function refreshQuestionIfVisible(questionId) {
    const question = (currentQuestions || []).find(q => q && q.id === questionId);
    if (!question) return;

    console.log(`[UI Refresh] Question ${questionId} is visible. Refreshing...`);
    try {
        if (question.type === 'multiple-choice' && typeof renderMCQDistribution === 'function') {
            renderMCQDistribution(questionId);
        } else if (question.type === 'free-response' && typeof renderFRQResponses === 'function') {
            renderFRQResponses(questionId);
        } else if (typeof populatePeerResponses === 'function') {
            populatePeerResponses(questionId, question.type);
        }
    } catch (error) {
        console.error(`[UI Refresh] Error during refresh for question ${questionId}:`, error);
    }
}

// --- END: NEW Real-Time Update Handling System ---

        async function initializeTurboMode() {
            // Test connection
            if (await testSupabaseConnection()) {
                // Do a smart sync (only sync what's needed)
                await smartSyncWithSupabase();

                // Pull initial peer data
                await pullPeerDataFromSupabase();

                // Update timestamp display
                updatePeerDataTimestamp();

                // Set up real-time subscriptions if available
                if (supabase && turboModeActive) {
                    // Subscribe to new answers
                    const subscription = supabase
                        .channel('answers_changes')
                        .on('postgres_changes',
                            { event: '*', schema: 'public', table: 'answers' },
                            (payload) => {
                                console.log('📨 Real-time update received:', payload);
                                // Trigger a sync check to pull the new data
                                performSyncCheck();
                            }
                        )
                        .subscribe();
                }

                // Start periodic sync (every 5 minutes)
                syncCheckInterval = setInterval(performSyncCheck, 5 * 60 * 1000);
            } else {
                // Start checking for connection every 30 seconds
                syncCheckInterval = setInterval(performSyncCheck, 30 * 1000);
            }

            // Always update timestamp on load
            updatePeerDataTimestamp();
        }

        // Helper functions for charts
        function generateChartColors(count) {
            const colors = [
                '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
                '#FF9F40', '#FF6384', '#C9CBCF', '#4BC0C0', '#FF6384'
            ];
            const result = [];
            for (let i = 0; i < count; i++) {
                result.push(colors[i % colors.length]);
            }
            return result;
        }

        function isDarkMode() {
            return document.body.classList.contains('dark-theme');
        }

        function getTextColor() {
            return isDarkMode() ? '#e0e0e0' : '#333333';
        }

        function getGridColor() {
            return isDarkMode() ? '#444444' : '#e0e0e0';
        }

        function getScatterPointColor() {
            return isDarkMode() ? '#5BC0EB' : '#36A2EB';
        }

        // Username Generation - moved to js/auth.js

        // Global variables
        let currentUsername = null;
        let classData = null;
        let currentUnit = null;
        let currentLesson = null;
        let currentQuestions = [];
        let allUnitQuestions = [];
        let chartInstances = {};
        let currentTheme = 'light';

        // Add this to your global variables
        let allCurriculumData = {}; // Store all units' data
        let qrCodesGenerated = false; // Track if QR codes have been generated

        // TASK 4.1: Track activity listeners for cleanup (memory leak prevention)
        let activityListeners = [];

        // TASK 4.2: Sprite base64 image (extracted from PigSprite CSS)
        // ========================================
        // TASK 5.2: FEATURE FLAG - SPRITES DISABLED
        // ========================================
        // TEMPORARY: Sprites disabled pending Canvas refactor
        // CSS sprite system has fundamental issues. Will rebuild with Canvas in Phase 5.
        const SPRITES_ENABLED = false;



        // Share Modal Functions
        function showShareModal() {
            const modal = document.getElementById('shareModal');
            modal.style.display = 'block';

            // Check if running locally and show local file path
            detectLocalFile();

            // Generate QR codes if not already generated
            if (!qrCodesGenerated) {
                generateQRCodes();
                qrCodesGenerated = true;
            }
        }

        function detectLocalFile() {
            const locationSection = document.querySelector('.current-location-section');
            const locationTitle = document.getElementById('locationTitle');
            const locationInput = document.getElementById('currentLocation');
            const locationDescription = document.getElementById('locationDescription');
            const locationInfo = document.getElementById('locationInfo');

            // Check if running from file:// protocol
            if (window.location.protocol === 'file:') {
                // RUNNING LOCALLY
                locationSection.classList.add('local-mode');
                locationSection.classList.remove('web-mode');
                locationTitle.innerHTML = '📁 Local File Location';

                // Get the local file path
                let localPath = window.location.href;

                // Clean up the path for better display
                localPath = localPath.replace('file:///', '');
                // On Windows, fix the drive letter format
                if (localPath.match(/^[A-Z]:/)) {
                    localPath = localPath.replace(/\//g, '\\');
                }
                // Decode URL encoding (spaces, special characters)
                localPath = decodeURIComponent(localPath);

                // Get just the directory path (remove index.html)
                const directoryPath = localPath.substring(0, localPath.lastIndexOf('/')) ||
                                    localPath.substring(0, localPath.lastIndexOf('\\'));

                locationInput.value = directoryPath || localPath;
                locationDescription.innerHTML = '🖥️ Running from your local computer';

                // Show local sharing instructions
                locationInfo.innerHTML = `
                    <p><strong>Share with classmates:</strong></p>
                    <ul style="text-align: left; margin: 10px auto; max-width: 400px;">
                        <li>Copy this entire folder to a USB drive</li>
                        <li>Upload the folder to a shared drive</li>
                        <li>Or use the GitHub repository above</li>
                    </ul>
                    <button onclick="openLocalFolder()" style="
                        margin-top: 15px;
                        background: white;
                        color: #e67e22;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 5px;
                        cursor: pointer;
                        font-weight: bold;
                    ">📂 Open Folder Location</button>
                `;
                locationInfo.style.display = 'block';
            } else {
                // RUNNING FROM WEB
                locationSection.classList.add('web-mode');
                locationSection.classList.remove('local-mode');
                locationTitle.innerHTML = '🌐 Current Web Location';

                // Get the current URL
                const currentUrl = window.location.href;
                const hostname = window.location.hostname;

                locationInput.value = currentUrl;

                // Check if it's the official GitHub Pages site
                if (hostname === 'robjohncolson.github.io') {
                    locationDescription.innerHTML = '✅ Running from the official website';
                    locationInfo.innerHTML = `
                        <p><strong>You're using the live version!</strong></p>
                        <ul style="text-align: left; margin: 10px auto; max-width: 400px;">
                            <li>Bookmark this page for easy access</li>
                            <li>Share the URL with classmates</li>
                            <li>No installation needed!</li>
                        </ul>
                    `;
                } else {
                    locationDescription.innerHTML = `🌍 Running from: ${hostname}`;
                    locationInfo.innerHTML = `
                        <p><strong>Custom deployment detected</strong></p>
                        <ul style="text-align: left; margin: 10px auto; max-width: 400px;">
                            <li>This appears to be a custom deployment</li>
                            <li>Make sure you trust this source</li>
                            <li>Official site: robjohncolson.github.io</li>
                        </ul>
                    `;
                }
                locationInfo.style.display = 'block';
            }
        }

        function closeShareModal() {
            const modal = document.getElementById('shareModal');
            modal.style.display = 'none';
        }

        function generateQRCodes() {
            // Clear any existing QR codes
            document.getElementById('websiteQR').innerHTML = '';
            document.getElementById('githubQR').innerHTML = '';

            // Generate website QR code
            new QRCode(document.getElementById('websiteQR'), {
                text: 'https://robjohncolson.github.io/curriculum_render',
                width: 200,
                height: 200,
                colorDark: isDarkMode() ? '#ff69b4' : '#3498db',
                colorLight: isDarkMode() ? '#2a2a2a' : '#ffffff',
                correctLevel: QRCode.CorrectLevel.H
            });

            // Generate GitHub QR code
            new QRCode(document.getElementById('githubQR'), {
                text: 'https://github.com/robjohncolson/curriculum_render',
                width: 200,
                height: 200,
                colorDark: isDarkMode() ? '#ff69b4' : '#3498db',
                colorLight: isDarkMode() ? '#2a2a2a' : '#ffffff',
                correctLevel: QRCode.CorrectLevel.H
            });
        }

        function copyToClipboard(elementId, label) {
            const input = document.getElementById(elementId);
            input.select();
            input.setSelectionRange(0, 99999); // For mobile devices

            try {
                document.execCommand('copy');
                showMessage(`${label} copied to clipboard!`, 'success');
            } catch (err) {
                // Fallback for newer browsers
                navigator.clipboard.writeText(input.value).then(function() {
                    showMessage(`${label} copied to clipboard!`, 'success');
                }, function(err) {
                    showMessage('Failed to copy URL', 'error');
                });
            }
        }

        function showMessage(message, type = 'info') {
            const messageArea = document.getElementById('messageArea');
            if (messageArea) {
                messageArea.innerHTML = `<div class="message ${type}">${message}</div>`;
                setTimeout(() => {
                    messageArea.innerHTML = '';
                }, 3000);
            }
        }

        function openLocalFolder() {
            const localPath = document.getElementById('currentLocation').value;

            // Try to open the folder in the system's file explorer
            // Note: This has limitations due to browser security
            if (localPath) {
                // For Windows, create a file:// URL with proper formatting
                let folderUrl;
                if (localPath.includes('\\')) {
                    // Windows path
                    folderUrl = 'file:///' + localPath.replace(/\\/g, '/');
                } else {
                    // Unix/Mac path
                    folderUrl = 'file://' + localPath;
                }

                // Try to open in a new window (may be blocked by browser)
                const opened = window.open(folderUrl, '_blank');

                if (!opened) {
                    showMessage('Cannot open folder directly. Please copy the path and open manually in your file explorer.', 'info');
                }
            }
        }


        // Unit structure - defines lessons per unit
        const unitStructure = {
            1: { name: 'Exploring One-Variable Data', lessons: 5 },
            2: { name: 'Exploring Two-Variable Data', lessons: 4 },
            3: { name: 'Collecting Data', lessons: 3 },
            4: { name: 'Probability & Random Variables', lessons: 5 },
            5: { name: 'Sampling Distributions', lessons: 4 },
            6: { name: 'Inference for Proportions', lessons: 4 },
            7: { name: 'Inference for Means', lessons: 4 },
            8: { name: 'Chi-Square Tests', lessons: 2 },
            9: { name: 'Inference for Slopes', lessons: 2 }
        };

        // Initialize class data - moved to js/data_manager.js

        // Student Performance Badges
        function calculateBadges(username) {
            const userAnswers = classData.users[username]?.answers || {};
            const userReasons = classData.users[username]?.reasons || {};
            const userAttempts = classData.users[username]?.attempts || {};

            const totalAnswers = Object.keys(userAnswers).length;
            if (totalAnswers === 0) return [];

            const badges = [];

            // Calculate outlier/conformist
            let modeMatches = 0;
            let outlierCount = 0;

            Object.keys(userAnswers).forEach(qId => {
                const allAnswers = Object.values(classData.users)
                    .map(u => u.answers?.[qId]?.value || u.answers?.[qId])
                    .filter(a => a);

                if (allAnswers.length > 1) {
                    const mode = getMostFrequent(allAnswers);
                    const userAnswer = userAnswers[qId]?.value || userAnswers[qId];
                    if (userAnswer === mode) modeMatches++;
                    else outlierCount++;
                }
            });

            if (outlierCount > totalAnswers * 0.5) badges.push('🎯 Outlier');
            if (modeMatches > totalAnswers * 0.8) badges.push('👥 Conformist');

            // Explorer badge
            const multiAttempts = Object.values(userAttempts).filter(a => a >= 2).length;
            if (multiAttempts > totalAnswers * 0.3) badges.push('🔄 Explorer');

            // Silent type vs Debater
            const reasonCount = Object.values(userReasons).filter(r => r && r.trim()).length;
            if (reasonCount < totalAnswers * 0.2) badges.push('🤐 Silent Type');
            else if (reasonCount > totalAnswers * 0.8) badges.push('💬 Debater');

            // Completionist
            const totalQuestions = currentQuestions.length;
            if (totalAnswers === totalQuestions && totalQuestions > 0) badges.push('✅ Completionist');

            return badges;
        }

        function getMostFrequent(arr) {
            const counts = {};
            arr.forEach(x => counts[x] = (counts[x] || 0) + 1);
            return Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);
        }

        // Check if question has been answered
        function isQuestionAnswered(questionId) {
            return classData.users[currentUsername]?.answers?.[questionId] !== undefined;
        }

        // Get attempt count for a question
        function getAttemptCount(questionId) {
            return classData.users[currentUsername]?.attempts?.[questionId] || 0;
        }

        // Check if can retry (has reason in previous attempt and < 3 attempts)
        function canRetry(questionId) {
            const attempts = getAttemptCount(questionId);
            if (attempts >= 3) return false;
            if (attempts === 0) return true;
            
            // Check if previous attempt had a reason
            const previousReason = classData.users[currentUsername]?.reasons?.[questionId];
            return previousReason && previousReason.trim().length > 0;
        }
        // Replace the entire detectUnitAndLessons function:
        function detectUnitAndLessons(questions) {
            if (!questions || questions.length === 0) return null;

            const firstId = questions[0].id;
            const unitMatch = firstId.match(/U(\d+)/i);
            if (!unitMatch) return null;

            const unitNum = parseInt(unitMatch[1]);

            // Group questions by lesson
            const lessonGroups = {};
            questions.forEach(q => {
                let lessonIdentifier;

                // Check for Progress Check questions first
                if (q.id.includes('-PC-')) {
                    lessonIdentifier = 'PC';
                } else {
                    // Match standard lesson format: U#-L#-
                    const lessonMatch = q.id.match(/U\d+-L(\d+)-/);
                    if (lessonMatch) {
                        lessonIdentifier = parseInt(lessonMatch[1]);
                    }
                }

                if (lessonIdentifier !== undefined) {
                    if (!lessonGroups[lessonIdentifier]) {
                        lessonGroups[lessonIdentifier] = [];
                    }
                    lessonGroups[lessonIdentifier].push(q);
                }
            });

            // Sort lesson numbers properly, with PC at the end
            const numericLessons = Object.keys(lessonGroups)
                .filter(key => typeof key === 'number' || !isNaN(key))
                .map(n => parseInt(n))
                .sort((a, b) => a - b);

            const allLessons = numericLessons.concat(lessonGroups['PC'] ? ['PC'] : []);

            console.log('Detected lessons:', allLessons); // Debug log
            console.log('Lesson groups:', Object.keys(lessonGroups)); // Debug log

            return {
                unitNumber: unitNum,
                lessons: lessonGroups,
                lessonNumbers: allLessons
            };
        }


       



        // Username management
        // Username prompting and session management - moved to js/auth.js

        // Function to import username from file
        window.importUsernameFromFile = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    // Try to find username in various formats
                    let username = null;

                    // Check for direct username field (personal export)
                    if (data.username) {
                        username = data.username;
                    }
                    // Check for master export format with exportTime and students
                    else if (data.exportTime && data.students) {
                        const usernames = Object.keys(data.students);
                        if (usernames.length === 1) {
                            username = usernames[0];
                        } else if (usernames.length > 1) {
                            // Show selection dialog for multiple users
                            showUsernameSelection(usernames, data);
                            return;
                        }
                    }
                    // Check for master database format with exportType
                    else if (data.exportType === 'master_database' && data.allUsers) {
                        if (data.allUsers.length === 1) {
                            username = data.allUsers[0];
                        } else if (data.allUsers.length > 1) {
                            showUsernameSelection(data.allUsers, data);
                            return;
                        }
                    }
                    // Check for class data format with users field
                    else if (data.users) {
                        const usernames = Object.keys(data.users);
                        if (usernames.length === 1) {
                            username = usernames[0];
                        } else if (usernames.length > 0) {
                            showUsernameSelection(usernames, data);
                            return;
                        }
                    }
                    // Check for students field (alternative format)
                    else if (data.students) {
                        const usernames = Object.keys(data.students);
                        if (usernames.length === 1) {
                            username = usernames[0];
                        } else if (usernames.length > 0) {
                            showUsernameSelection(usernames, data);
                            return;
                        }
                    }

                    if (username) {
                        // If we found a single username, import the data directly
                        importDataForUser(username, data);
                    } else {
                        showMessage('No username found in this file', 'error');
                    }

                } catch (error) {
                    showMessage('Invalid file format', 'error');
                }
            };
            reader.readAsText(file);
        }

        // Function to show username selection dialog
        // Store import data globally for use after username selection
        let pendingImportData = null;

        function showUsernameSelection(usernames, importData = null) {
            // Store the import data for later use
            pendingImportData = importData;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';

            let optionsHTML = usernames.map(u =>
                `<button onclick="selectUsername('${u}')" class="username-option">
                    ${u}
                </button>`
            ).join('');

            modal.innerHTML = `
                <div class="modal-content">
                    <span class="close-modal" onclick="closeUsernameSelection()">&times;</span>
                    <h3>Select Your Username</h3>
                    <p>Multiple usernames found. Please select yours:</p>
                    <div class="username-options">
                        ${optionsHTML}
                    </div>
                    ${importData ? '<p><small>After selection, your data will be imported.</small></p>' : ''}
                </div>
            `;

            document.body.appendChild(modal);
        }

        window.selectUsername = function(username) {
            document.querySelector('.modal').remove();

            // If we have pending import data, import it first
            if (pendingImportData) {
                importDataForUser(username, pendingImportData);
                pendingImportData = null;
            } else {
                checkExistingData(username);
            }
        }

        window.closeUsernameSelection = function() {
            document.querySelector('.modal').remove();
            pendingImportData = null;
        }

        // --- Start of New Code for Phase 2 (Revised) ---

        function showRestoreOptionsModal() {
            // Prevent creating duplicate modals
            if (document.getElementById('restoreOptionsModal')) {
                return;
            }

            const modal = document.createElement('div');
            modal.id = 'restoreOptionsModal';
            modal.className = 'modal';

            // Using the exact HTML structure you provided in Phase 1
            modal.innerHTML = `
                <div class="modal-content enhanced-sync-modal">
                    <span class="close-modal" onclick="closeRestoreOptionsModal()">&times;</span>
                    <h3>Choose Restore Method</h3>

                    <div class="restore-option">
                        <h4>🏫 Classroom Restore</h4>
                        <p>Your teacher has a master file and a class roster to restore your account.</p>
                        <button class="action-button primary" onclick="showCSVImportModal(); closeRestoreOptionsModal();">
                            Use Classroom File
                        </button>
                    </div>

                    <div class="restore-option">
                        <h4>💾 Personal Restore</h4>
                        <p>You have your username and your personal backup (.json) file.</p>
                        <input type="text" id="manualUsernameInput" class="username-input"
                               placeholder="Enter your username (e.g., Apple_Bear)">
                        <button id="continueWithUsernameBtn" class="action-button primary">
                            Continue to Import
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
            modal.style.display = 'block';

           // --- Start of New Code for Phase 3 (Revised) ---

// Attach the event listener for the "Continue to Import" button now that it exists in the DOM.
const continueBtn = document.getElementById('continueWithUsernameBtn');
if (continueBtn) {
    continueBtn.onclick = function() {
        const usernameInput = document.getElementById('manualUsernameInput');
        const username = usernameInput.value.trim();

        // 1. Validate that the username is not empty.
        if (!username) {
            // Use the existing showMessage function for consistent UI feedback.
            if (typeof showMessage === 'function') {
                showMessage('Please enter a username to continue.', 'error');
            } else {
                alert('Please enter a username to continue.');
            }
            return;
        }
        
        // 2. Call the existing `acceptUsername` function to establish the session.
        // CRITICAL: We use the username with its original capitalization to match the "Fruit_Animal" format.
        acceptUsername(username);
        
        // 3. Close the modal.
        closeRestoreOptionsModal();

        // 4. Display a helpful guidance message to the user.
        if (typeof showMessage === 'function') {
            showMessage(`Welcome, ${username}! Use the Sync button (⚡️) to import your personal backup file.`, 'info');
        }
    };
}

// --- End of New Code for Phase 3 (Revised) ---

            // Automatically focus the input field for a better user experience
            const usernameInput = document.getElementById('manualUsernameInput');
            if (usernameInput) {
                usernameInput.focus();
            }
        }

        function closeRestoreOptionsModal() {
            const modal = document.getElementById('restoreOptionsModal');
            if (modal) {
                modal.remove();
            }
        }

        // --- End of New Code for Phase 2 (Revised) ---/
        // / --- Start of mergePersonalData Function for Phase 4.1 ---

  /**
   * Merges two user data objects with non-destructive timestamp-based logic.
   * This function implements the approved merge rules for handling multiple personal backup imports.
   * 
   * @param {Object} existingUserData - The current user's data from classData.users[username]
   * @param {Object} newUserData - The incoming user data from an imported file
   * @returns {Object} The merged user data object with the most recent/relevant information
   */
  function mergePersonalData(existingUserData, newUserData) {
      try {
          console.log('=== Starting mergePersonalData ===');

          // 1. Initialization and Edge Cases
          // If no existing data, return the new data immediately
          if (!existingUserData || Object.keys(existingUserData).length === 0) {
              console.log('No existing data found, returning new data as-is');
              return newUserData || {};
          }

          // If no new data, return existing data
          if (!newUserData || Object.keys(newUserData).length === 0) {
              console.log('No new data to merge, returning existing data');
              return existingUserData;
          }

          // Create a deep copy of existingUserData to avoid mutations
          let mergedUserData = JSON.parse(JSON.stringify(existingUserData));

          // Ensure all primary keys exist on mergedUserData
          mergedUserData.answers = mergedUserData.answers || {};
          mergedUserData.reasons = mergedUserData.reasons || {};
          mergedUserData.timestamps = mergedUserData.timestamps || {};
          mergedUserData.attempts = mergedUserData.attempts || {};
          mergedUserData.progress = mergedUserData.progress || {};
          mergedUserData.badges = mergedUserData.badges || {};
          mergedUserData.preferences = mergedUserData.preferences || {};

          // Also ensure newUserData has these structures for safe access
          newUserData.answers = newUserData.answers || {};
          newUserData.reasons = newUserData.reasons || {};
          newUserData.timestamps = newUserData.timestamps || {};
          newUserData.attempts = newUserData.attempts || {};
          newUserData.progress = newUserData.progress || {};

          // 2. Merge Answers, Timestamps, and Reasons
          console.log('Merging answers based on timestamps...');
          let answersUpdated = 0;

          for (const questionId in newUserData.answers) {
              try {
                  const newAnswer = newUserData.answers[questionId];
                  const existingAnswer = mergedUserData.answers[questionId];

                  // Extract timestamps - handle both direct timestamps and answer objects with timestamp property
                  let newTimestamp = null;
                  let existingTimestamp = null;

                  // Check for timestamp in various possible locations
                  if (newAnswer && typeof newAnswer === 'object' && newAnswer.timestamp) {
                      newTimestamp = newAnswer.timestamp;
                  } else if (newUserData.timestamps && newUserData.timestamps[questionId]) {
                      newTimestamp = newUserData.timestamps[questionId];
                  }

                  if (existingAnswer && typeof existingAnswer === 'object' && existingAnswer.timestamp) {
                      existingTimestamp = existingAnswer.timestamp;
                  } else if (mergedUserData.timestamps && mergedUserData.timestamps[questionId]) {
                      existingTimestamp = mergedUserData.timestamps[questionId];
                  }

                  // Convert timestamps to numbers for comparison
                  newTimestamp = Number(newTimestamp) || 0;
                  existingTimestamp = Number(existingTimestamp) || 0;

                  // Rule: If new answer is more recent (or no existing answer), update all related fields
                  if (!existingAnswer || newTimestamp > existingTimestamp) {
                      mergedUserData.answers[questionId] = newAnswer;
                      mergedUserData.timestamps[questionId] = newTimestamp || newUserData.timestamps[questionId];

                      // Update reason if it exists for this question
                      if (newUserData.reasons && newUserData.reasons[questionId]) {
                          mergedUserData.reasons[questionId] = newUserData.reasons[questionId];
                      }

                      answersUpdated++;
                      console.log(`  Updated ${questionId}: timestamp ${newTimestamp} > ${existingTimestamp}`);
                  } else if (newTimestamp === existingTimestamp && existingTimestamp > 0) {
                      // Edge Case: If timestamps are identical, preserve existing data
                      console.log(`  Preserved ${questionId}: timestamps identical (${existingTimestamp})`);
                  }

              } catch (answerError) {
                  console.error(`Error merging answer for ${questionId}:`, answerError);
                  // Continue processing other answers
              }
          }

          console.log(`Updated ${answersUpdated} answers based on timestamps`);

          // 3. Merge Attempts
          console.log('Merging attempt counts...');
          let attemptsUpdated = 0;

          for (const questionId in newUserData.attempts) {
              const existingAttempts = Number(mergedUserData.attempts[questionId]) || 0;
              const newAttempts = Number(newUserData.attempts[questionId]) || 0;

              // Rule: Keep the highest attempt count
              const maxAttempts = Math.max(existingAttempts, newAttempts);

              if (maxAttempts !== existingAttempts) {
                  mergedUserData.attempts[questionId] = maxAttempts;
                  attemptsUpdated++;
                  console.log(`  Updated attempts for ${questionId}: ${existingAttempts} -> ${maxAttempts}`);
              }
          }

          // Also check for attempts in existing data that aren't in new data
          for (const questionId in mergedUserData.attempts) {
              if (!(questionId in newUserData.attempts)) {
                  // Keep existing attempts for questions not in new data
                  console.log(`  Preserved attempts for ${questionId}: ${mergedUserData.attempts[questionId]}`);
              }
          }

          console.log(`Updated ${attemptsUpdated} attempt counts`);

          // 4. Merge Progress
          console.log('Merging progress indicators...');
          let progressUpdated = 0;

          for (const key in newUserData.progress) {
              const existingProgress = Number(mergedUserData.progress[key]) || 0;
              const newProgress = Number(newUserData.progress[key]) || 0;

              // Rule: Keep the maximum progress value
              const maxProgress = Math.max(existingProgress, newProgress);

              if (maxProgress !== existingProgress) {
                  mergedUserData.progress[key] = maxProgress;
                  progressUpdated++;
                  console.log(`  Updated progress.${key}: ${existingProgress} -> ${maxProgress}`);
              }
          }

          console.log(`Updated ${progressUpdated} progress indicators`);

          // 5. Merge Badges (bonus: merge unique badges, keeping earliest timestamp)
          if (newUserData.badges) {
              console.log('Merging badges...');
              mergedUserData.badges = mergedUserData.badges || {};

              for (const badge in newUserData.badges) {
                  if (!mergedUserData.badges[badge]) {
                      // New badge not in existing data
                      mergedUserData.badges[badge] = newUserData.badges[badge];
                      console.log(`  Added new badge: ${badge}`);
                  } else {
                      // Badge exists - keep the one with earlier timestamp (first earned)
                      const existingBadgeTime = mergedUserData.badges[badge].earnedAt || 0;
                      const newBadgeTime = newUserData.badges[badge].earnedAt || 0;

                      if (newBadgeTime && (!existingBadgeTime || newBadgeTime < existingBadgeTime)) {
                          mergedUserData.badges[badge] = newUserData.badges[badge];
                          console.log(`  Updated badge ${badge} with earlier timestamp`);
                      }
                  }
              }
          }

          // 6. Merge Preferences (use most recent)
          if (newUserData.preferences) {
              // For preferences, we'll take the entire new preferences object if it exists
              // as preferences are typically set as a complete unit
              mergedUserData.preferences = newUserData.preferences;
              console.log('Updated user preferences with latest values');
          }

          console.log('=== Merge complete ===');
          console.log(`Final merged data contains ${Object.keys(mergedUserData.answers).length} answers`);

          return mergedUserData;

      } catch (error) {
          console.error('Fatal error in mergePersonalData:', error);
          console.error('Stack trace:', error.stack);

          // In case of catastrophic failure, preserve existing data
          console.log('Returning existing data due to merge error');
          return existingUserData || {};
      }
  }

  // --- End of mergePersonalData Function for Phase 4.1 ---
    // --- Start of importAndMergePersonalData Function for Phase 4.2 ---

  /**
   * Wrapper function that imports personal data with non-destructive merging.
   * This function handles the integration of imported data using the mergePersonalData logic.
   * 
   * @param {Object} importedData - The imported user data object from a JSON file
   */
   function importAndMergePersonalData(importedData) {
      console.log('=== Starting importAndMergePersonalData ===');

      try {
          // 1. Get the currentUsername - if not set, show error and return
          if (!currentUsername) {
              showMessage('No username set. Please establish a session first.', 'error');
              console.error('No currentUsername set');
              return;
          }

          console.log('Processing import for username:', currentUsername);

          // 2. Load the entire classData object from localStorage
          let classData = JSON.parse(localStorage.getItem('classData') || '{}');

          // Ensure classData has the users object
          if (!classData.users) {
              classData.users = {};
          }

          // 3. Safely access the user's existing data slice
          let existingUserData = classData.users[currentUsername] || {};
          console.log('Existing user data keys:', Object.keys(existingUserData));

          // 4. Prepare the imported data for merging
          // First, check if importedData has the user's data nested inside
          let dataToMerge = null;

          // Handle different import formats
          if (importedData.users && importedData.users[currentUsername]) {
              // Data is in master export format with users object
              dataToMerge = importedData.users[currentUsername];
              console.log('Found user data in users object');
            } else if (importedData.username && importedData.username === currentUsername && importedData.users && importedData.users[currentUsername]) {
      // Personal export format with username field
      dataToMerge = importedData.users[currentUsername];
      console.log('Found user data in personal export format');
          } else if (importedData.username === currentUsername && importedData.answers) {
              // Data is in personal export format
              dataToMerge = {
                  answers: importedData.answers || {},
                  reasons: importedData.reasons || {},
                  timestamps: importedData.timestamps || {},
                  attempts: importedData.attempts || {},
                  progress: importedData.progress || {},
                  badges: importedData.badges || {},
                  preferences: importedData.preferences || {}
              };
              console.log('Using personal export format');
          } else if (importedData.answers) {
              // Direct data object format
              dataToMerge = importedData;
              console.log('Using direct data format');
          } else {
              showMessage('Could not find data for your username in the imported file.', 'error');
              console.error('No matching data found for username:', currentUsername);
              return;
          }

          // Migrate answers to standard format if the function exists
          if (typeof migrateAnswersToStandardFormat === 'function' && dataToMerge.answers) {
              console.log('Migrating answers to standard format...');
              dataToMerge.answers = migrateAnswersToStandardFormat(dataToMerge.answers);
          }

          // 5. Call mergePersonalData to merge the data
          console.log('Calling mergePersonalData...');
          let mergedUserData = mergePersonalData(existingUserData, dataToMerge);

          // 6. Update the main data structure in memory
          classData.users[currentUsername] = mergedUserData;
          console.log('Updated classData.users for', currentUsername);

          // 7. Save the entire updated classData object back to localStorage
          localStorage.setItem('classData', JSON.stringify(classData));
          console.log('Saved updated classData to localStorage');

          // 8. Call initClassData() to refresh global variables from the new state
          if (typeof initClassData === 'function') {
              initClassData();
              console.log('Reinitialized class data');
          }

          // 9. Refresh the UI with the merged data
          // Try to refresh visualizations if the function exists
          if (typeof refreshAllVisualizations === 'function') {
              refreshAllVisualizations();
              console.log('Refreshed all visualizations');
          } else if (typeof updateProgressDisplay === 'function') {
              updateProgressDisplay();
              console.log('Updated progress display');
          }

          // If we're on a question page, reload it to show the merged data
          if (typeof currentQuestionId !== 'undefined' && currentQuestionId) {
              if (typeof loadQuestion === 'function') {
                  // Extract topic and question number from currentQuestionId if possible
                  const parts = currentQuestionId.split('-');
                  if (parts.length >= 3) {
                      const topic = parts[0] + '-' + parts[1];
                      const questionNum = parseInt(parts[2].replace('Q', ''));
                      loadQuestion(topic, questionNum);
                      console.log('Reloaded current question');
                  }
              }
          }

          // 10. Show success message
          const answerCount = Object.keys(mergedUserData.answers || {}).length;
          showMessage(`Successfully merged your personal data! You now have ${answerCount} answers.`, 'success');
          console.log('=== Merge complete ===');
          console.log(`Final data contains ${answerCount} answers`);

      } catch (error) {
          console.error('Error in importAndMergePersonalData:', error);
          console.error('Stack trace:', error.stack);
          showMessage('Error merging personal data: ' + error.message, 'error');
      }
  }

  // --- End of importAndMergePersonalData Function for Phase 4.2 ---

        // Function to import data for a specific user
        function importDataForUser(username, importData) {
            console.log('=== importDataForUser called ===');
            console.log('Target username:', username);
            console.log('Import data:', importData);
            console.log('Import data keys:', Object.keys(importData));

            try {
                // Set the username first
                currentUsername = username;
                localStorage.setItem('consensusUsername', username);
                initClassData();

                let userData = null;
                let allStudentsData = {};
                let importSuccess = false;

                // Helper function to find username with case-insensitive matching
                function findUserData(dataObj, targetUsername) {
                    // Try exact match first
                    if (dataObj[targetUsername]) {
                        return { key: targetUsername, data: dataObj[targetUsername] };
                    }
                    // Try case-insensitive match
                    const lowerTarget = targetUsername.toLowerCase();
                    for (const key in dataObj) {
                        if (key.toLowerCase() === lowerTarget) {
                            console.log(`Found case-insensitive match: ${targetUsername} -> ${key}`);
                            return { key: key, data: dataObj[key] };
                        }
                    }
                    return null;
                }

                // DETECTION 1: Master file with "students" field (current format)
                if (importData.exportTime && importData.students) {
                    const userMatch = findUserData(importData.students, username);
                    if (userMatch) {
                        console.log('Detected: Master file with students field');
                        userData = userMatch.data;
                        allStudentsData = importData.students;
                        importSuccess = true;
                    }
                }
                // DETECTION 2: Legacy individual file with "users" field
                else if (importData.exportTime && importData.users) {
                    const userMatch = findUserData(importData.users, username);
                    if (userMatch) {
                        console.log('Detected: Legacy individual file with users field');
                        userData = userMatch.data;
                        allStudentsData = importData.users;
                        importSuccess = true;
                    }
                }
                // DETECTION 3: Master database export format
                else if (importData.exportType === 'master_database') {
                    console.log('Detected: Master database format');
                    if (importData.allAnswers && importData.allAnswers[username]) {
                        // STANDARDIZATION FIX: Use migration function for consistency
                        const standardizedAnswers = migrateAnswersToStandardFormat(importData.allAnswers[username]);
                        localStorage.setItem(`answers_${username}`, JSON.stringify(standardizedAnswers));
                        importSuccess = true;
                    }
                    if (importData.allProgress && importData.allProgress[username]) {
                        localStorage.setItem(`progress_${username}`, JSON.stringify(importData.allProgress[username]));
                    }
                    if (importData.classData) {
                        localStorage.setItem('classData', JSON.stringify(importData.classData));
                    }
                    showMessage(`Master database imported successfully for ${username}!`, 'success');
                }
                // DETECTION 4: Simple username-only format (fallback)
                else if (importData.username || importData.consensusUsername) {
                    console.log('Detected: Username-only format');
                    showMessage(`Username set to ${username} from import file.`, 'success');
                    importSuccess = true;
                }

                // Process user data if found (for formats 1 & 2)
                if (userData) {
                    console.log(`Processing user data for ${username}:`, userData);

                    // Import user's personal data to both individual keys AND classData structure
                    if (userData.answers) {
                        // STANDARDIZATION FIX: Use migration function for consistency
                        const standardizedAnswers = migrateAnswersToStandardFormat(userData.answers);
                        localStorage.setItem(`answers_${username}`, JSON.stringify(standardizedAnswers));
                        console.log(`Imported ${Object.keys(standardizedAnswers).length} answers for ${username} (standardized format)`);
                    }
                    if (userData.reasons) {
                        localStorage.setItem(`reasons_${username}`, JSON.stringify(userData.reasons));
                        console.log(`Imported ${Object.keys(userData.reasons).length} reasons for ${username}`);
                    }
                    if (userData.progress) {
                        localStorage.setItem(`progress_${username}`, JSON.stringify(userData.progress));
                    }
                    if (userData.timestamps) {
                        localStorage.setItem(`timestamps_${username}`, JSON.stringify(userData.timestamps));
                    }
                    if (userData.attempts) {
                        localStorage.setItem(`attempts_${username}`, JSON.stringify(userData.attempts));
                    }

                    // CRITICAL: Update classData for both current user AND peer data
                    const classData = JSON.parse(localStorage.getItem('classData') || '{}');
                    if (!classData.users) classData.users = {};

                    // First, ensure current user exists in classData and populate their data
                    if (!classData.users[username]) {
                        classData.users[username] = { answers: {}, reasons: {}, timestamps: {}, attempts: {} };
                    }
                    if (userData.answers) {
                        // STANDARDIZATION FIX: Use migration function for current user too
                        const standardizedAnswers = migrateAnswersToStandardFormat(userData.answers);
                        Object.assign(classData.users[username].answers, standardizedAnswers);
                        // Also update timestamps
                        Object.keys(standardizedAnswers).forEach(qId => {
                            classData.users[username].timestamps[qId] = standardizedAnswers[qId].timestamp;
                        });
                    }
                    if (userData.reasons) Object.assign(classData.users[username].reasons, userData.reasons);
                    if (userData.timestamps) Object.assign(classData.users[username].timestamps, userData.timestamps);
                    if (userData.attempts) Object.assign(classData.users[username].attempts, userData.attempts);
                    console.log(`Updated classData for current user ${username} with ${Object.keys(userData.answers || {}).length} answers (standardized format)`);

                    let peerCount = 0;
                    Object.keys(allStudentsData).forEach(otherUsername => {
                        if (otherUsername !== username) {
                            peerCount++;
                            if (!classData.users[otherUsername]) {
                                classData.users[otherUsername] = { answers: {}, reasons: {}, timestamps: {}, attempts: {} };
                            }

                            const otherUserData = allStudentsData[otherUsername];
                            if (otherUserData.answers) {
                                // STANDARDIZATION FIX: Use consistent object format for peer data too
                                const standardizedAnswers = migrateAnswersToStandardFormat(otherUserData.answers);
                                Object.keys(standardizedAnswers).forEach(questionId => {
                                    const answerObj = standardizedAnswers[questionId];
                                    // Store the full object, not just the value
                                    classData.users[otherUsername].answers[questionId] = answerObj;
                                    // Also store timestamp separately for backward compatibility
                                    classData.users[otherUsername].timestamps[questionId] = answerObj.timestamp;
                                });
                            }
                            if (otherUserData.reasons) {
                                Object.assign(classData.users[otherUsername].reasons, otherUserData.reasons);
                            }
                            if (otherUserData.attempts) {
                                Object.assign(classData.users[otherUsername].attempts, otherUserData.attempts);
                            }
                        }
                    });

                    localStorage.setItem('classData', JSON.stringify(classData));
                    showMessage(`Data imported successfully for ${username}! Found ${peerCount} peer students.`, 'success');
                }

                if (!importSuccess) {
                    throw new Error('Unrecognized file format - check your file structure');
                }

                // Initialize and show welcome, then navigate to units
                showUsernameWelcome();
                initializeFromEmbeddedData();

                // Auto-navigate to units page after successful import
                setTimeout(() => {
                    showMessage(`Successfully imported data for ${username}! Redirecting to units...`, 'success');
                }, 500);

            } catch (error) {
                showMessage('Error importing data: ' + error.message, 'error');
                console.error('Import error:', error);
            }
        }

        // CSV Integration Functions
        let csvMappingData = null;
        let masterDataForCSV = null;

        window.showCSVImportModal = function() {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.id = 'csvImportModal';

            modal.innerHTML = `
                <div class="modal-content">
                    <span class="close-modal" onclick="closeCSVImportModal()">&times;</span>
                    <h3>📊 CSV Import Setup</h3>
                    <p>Import master class data with CSV student mapping</p>

                    <div class="csv-import-steps">
                        <div class="import-step">
                            <h4>Step 1: Select Master Data File</h4>
                            <p>Choose your exported class data (JSON file)</p>
                            <input type="file"
                                   id="masterDataFile"
                                   accept=".json"
                                   onchange="loadMasterDataFile(event)">
                            <div id="masterDataStatus" class="file-status"></div>
                        </div>

                        <div class="import-step">
                            <h4>Step 2: Select CSV Student Roster</h4>
                            <p>Choose CSV file with student names and usernames<br>
                               <small>Format: Student Name, Username (comma-separated)</small></p>
                            <input type="file"
                                   id="csvMappingFile"
                                   accept=".csv"
                                   onchange="loadCSVMappingFile(event)">
                            <div id="csvMappingStatus" class="file-status"></div>
                        </div>

                        <div class="import-step">
                            <h4>Step 3: Select Your Name</h4>
                            <p>Choose your name from the CSV roster</p>
                            <select id="studentNameSelect" disabled>
                                <option value="">Load CSV file first...</option>
                            </select>
                        </div>

                        <div class="csv-import-actions">
                            <button onclick="processCSVImport()"
                                    id="processCSVImportBtn"
                                    class="action-button primary"
                                    disabled>
                                Import Data
                            </button>
                            <button onclick="closeCSVImportModal()"
                                    class="action-button secondary">
                                Cancel
                            </button>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        window.closeCSVImportModal = function() {
            const modal = document.getElementById('csvImportModal');
            if (modal) {
                modal.remove();
            }
            csvMappingData = null;
            masterDataForCSV = null;
        }

        window.loadMasterDataFile = function(event) {
            console.log('=== loadMasterDataFile called ===');
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    masterDataForCSV = JSON.parse(e.target.result);
                    console.log('Master data loaded:', masterDataForCSV);

                    const studentCount = Object.keys(masterDataForCSV.students || masterDataForCSV.allUsers || {}).length;
                    document.getElementById('masterDataStatus').innerHTML =
                        `<span style="color: green;">✓ Master data loaded (${studentCount} students)</span>`;
                    checkCSVImportReady();
                } catch (error) {
                    document.getElementById('masterDataStatus').innerHTML =
                        `<span style="color: red;">✗ Invalid JSON file</span>`;
                    masterDataForCSV = null;
                }
            };
            reader.readAsText(file);
        }

        // New function to import all peer data directly
        window.importAllPeerData = function() {
            if (!masterDataForCSV) {
                showMessage('No master data loaded', 'error');
                return;
            }

            console.log('=== Importing all peer data ===');
            importMasterData(masterDataForCSV);
            showMessage('✅ All peer data imported successfully!', 'success');
            closeCSVImportModal();
        }

        window.loadCSVMappingFile = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvText = e.target.result;
                    csvMappingData = parseCSVMapping(csvText);

                    if (csvMappingData && csvMappingData.length > 0) {
                        populateStudentSelect(csvMappingData);
                        document.getElementById('csvMappingStatus').innerHTML =
                            `<span style="color: green;">✓ CSV loaded (${csvMappingData.length} students)</span>`;
                        checkCSVImportReady();
                    } else {
                        document.getElementById('csvMappingStatus').innerHTML =
                            `<span style="color: red;">✗ No student data found. Check CSV format.</span>`;
                    }
                } catch (error) {
                    document.getElementById('csvMappingStatus').innerHTML =
                        `<span style="color: red;">✗ Error reading CSV file</span>`;
                    csvMappingData = null;
                }
            };
            reader.readAsText(file);
        }

        function parseCSVMapping(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 1) return null;

            const students = [];
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                // Split by comma and clean up the values
                const parts = line.split(',').map(part => part.trim().replace(/^["']|["']$/g, ''));
                if (parts.length >= 2 && parts[0] && parts[1]) {
                    students.push({
                        name: parts[0],
                        username: parts[1]
                    });
                }
            }

            return students.length > 0 ? students : null;
        }

        function populateStudentSelect(mappingData) {
            const select = document.getElementById('studentNameSelect');
            select.innerHTML = '<option value="">Select your name...</option>';

            mappingData.forEach((student, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `${student.name} (${student.username})`;
                select.appendChild(option);
            });

            select.disabled = false;
        }

        function checkCSVImportReady() {
            const btn = document.getElementById('processCSVImportBtn');
            if (masterDataForCSV && csvMappingData) {
                btn.disabled = false;
            }
        }

        window.processCSVImport = function() {
            const selectedIndex = document.getElementById('studentNameSelect').value;
            if (!selectedIndex || !csvMappingData || !masterDataForCSV) {
                showMessage('Please complete all steps first', 'error');
                return;
            }

            const selectedStudent = csvMappingData[selectedIndex];
            const username = selectedStudent.username;

            // Save data before closing modal (since closeCSVImportModal clears it)
            const savedMasterData = masterDataForCSV;

            // Close modal
            closeCSVImportModal();

            // Import data for the selected user
            showMessage(`Importing data for ${selectedStudent.name} (${username})...`, 'info');
            importDataForUser(username, savedMasterData);
        }

        // Global ESC Key Handler for All Modals
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                // Find any open modal and close it
                const modals = [
                    'syncModal',
                    'csvImportModal',
                    'userManagementModal'
                ];

                for (const modalId of modals) {
                    const modal = document.getElementById(modalId);
                    if (modal && modal.style.display !== 'none') {
                        // Close the modal using the appropriate close function
                        switch (modalId) {
                            case 'syncModal':
                                if (typeof closeSyncModal === 'function') {
                                    closeSyncModal();
                                } else {
                                    modal.style.display = 'none';
                                }
                                break;
                            case 'csvImportModal':
                                closeCSVImportModal();
                                break;
                            case 'userManagementModal':
                                closeUserManagement();
                                break;
                        }
                        event.preventDefault();
                        break; // Only close one modal at a time
                    }
                }

                // Also check for any generic modals with class 'modal'
                const genericModals = document.querySelectorAll('.modal');
                for (const modal of genericModals) {
                    if (modal.style.display !== 'none' && modal.offsetParent !== null) {
                        // Try to find a close button and click it
                        const closeBtn = modal.querySelector('.close-modal');
                        if (closeBtn) {
                            closeBtn.click();
                            event.preventDefault();
                            break;
                        } else {
                            // Fallback: just hide the modal
                            modal.style.display = 'none';
                            event.preventDefault();
                            break;
                        }
                    }
                }
            }
        });

        // Global Ctrl+S Shortcut Handler
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey && event.key === 's') {
                // Check if user is typing in an input field
                const activeElement = document.activeElement;
                const isTyping = activeElement && (
                    activeElement.tagName === 'TEXTAREA' ||
                    activeElement.tagName === 'INPUT' ||
                    activeElement.contentEditable === 'true' ||
                    activeElement.classList.contains('frq-textarea') ||
                    activeElement.classList.contains('reason-textarea')
                );

                // Don't trigger if user is typing
                if (isTyping) {
                    return;
                }

                // Prevent browser's default save behavior
                event.preventDefault();

                // Flash green effect
                flashGreenScreen();

                // Open sync modal after flash
                setTimeout(() => {
                    showSyncModal();
                }, 150);
            }
        });

        // Green flash effect function
        function flashGreenScreen() {
            const flash = document.createElement('div');
            flash.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background-color: rgba(76, 175, 80, 0.3);
                z-index: 999999;
                pointer-events: none;
                animation: flashFade 0.3s ease-out;
            `;

            // Add CSS animation if not exists
            if (!document.querySelector('#flashAnimation')) {
                const style = document.createElement('style');
                style.id = 'flashAnimation';
                style.textContent = `
                    @keyframes flashFade {
                        0% { opacity: 0; }
                        50% { opacity: 1; }
                        100% { opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }

            document.body.appendChild(flash);

            // Remove flash after animation
            setTimeout(() => {
                if (flash.parentNode) {
                    flash.parentNode.removeChild(flash);
                }
            }, 300);
        }

        // Unified Sync Modal System

        window.closeSyncModal = function() {
            const modal = document.getElementById('unifiedSyncModal');
            if (modal) {
                modal.remove();
            }
        }



        // Call this function whenever currentUsername changes
        // Username display functions - moved to js/auth.js

        // Curriculum initialization - moved to js/data_manager.js

        // Unit selector - REMOVED: No longer needed due to CORS issues
        // function renderUnitSelector() {
        //     const questionsContainer = document.getElementById('questionsContainer');
        //     let buttonsHtml = '';
        //
        //     for (let unitNum in unitStructure) {
        //         const unit = unitStructure[unitNum];
        //         buttonsHtml += `
        //             <button onclick="loadUnit(${unitNum})" class="unit-btn" id="unit-btn-${unitNum}">
        //                 <strong>Unit ${unitNum}</strong><br>
        //                 ${unit.name}
        //             </button>
        //         `;
        //     }
        //
        //     questionsContainer.innerHTML = `
        //         <div class="unit-selector">
        //             <h2>Select a Unit</h2>
        //             <div class="unit-buttons">
        //                 ${buttonsHtml}
        //             </div>
        //         </div>
        //     `;
        // }

        // Load unit
        window.loadUnit = async function(unitNumber) {
            const btn = document.getElementById(`unit-btn-${unitNumber}`);
            if (btn) {
                btn.classList.add('loading');
                btn.disabled = true;
            }

            try {
                const response = await fetch(`unit${unitNumber}.json`);
                if (!response.ok) {
                    throw new Error(`Unit ${unitNumber} file not found`);
                }
                const data = await response.json();
                currentUnit = unitNumber;
                allUnitQuestions = Array.isArray(data) ? data : (data.questions || []);
                
                renderLessonSelector();
                showMessage(`Unit ${unitNumber} loaded successfully!`, 'success');
            } catch (error) {
                showMessage(`Error loading Unit ${unitNumber}: ${error.message}`, 'error');
                if (btn) {
                    btn.classList.remove('loading');
                    btn.disabled = false;
                }
            }
        }

        // Render lesson selector
function renderLessonSelector(unitInfo) {
    const questionsContainer = document.getElementById('questionsContainer');
    
    // If unitInfo provided (from file load), use it
    if (unitInfo && unitInfo.lessonNumbers) {
        let lessonButtonsHtml = '';
        
        unitInfo.lessonNumbers.forEach(lessonNum => {
            const questions = unitInfo.lessons[lessonNum];
            const isCompleted = questions.every(q => isQuestionAnswered(q.id));
            const displayName = lessonNum === 'PC' ? 'Progress Check' : `Lesson ${lessonNum}`;
            const buttonId = lessonNum === 'PC' ? 'lesson-btn-PC' : `lesson-btn-${lessonNum}`;

            lessonButtonsHtml += `
                <button onclick="loadLesson('${lessonNum}')"
                        class="lesson-btn ${isCompleted ? 'completed' : ''}"
                        id="${buttonId}">
                    ${displayName}<br>
                    <small>${questions.length} questions</small>
                </button>
            `;
        });
        
        questionsContainer.innerHTML = `
            <button onclick="backToUnits()" class="back-button">← Back to Units</button>
            <div class="lesson-selector">
                <h3>Unit ${currentUnit}: ${unitStructure[currentUnit]?.name || 'Unknown Unit'}</h3>
                <p>Select a lesson to begin:</p>
                <div class="lesson-buttons">
                    ${lessonButtonsHtml}
                </div>
            </div>
        `;
        return;
    }
    
    // Old fallback code for when called without unitInfo
    const unit = unitStructure[currentUnit];
    if (!unit) return;
    
    let lessonButtonsHtml = '';
    
    // Group questions by lesson
    const lessonGroups = {};
    allUnitQuestions.forEach(q => {
        const match = q.id.match(/L(\d+)/);
        if (match) {
            const lessonNum = parseInt(match[1]);
            if (!lessonGroups[lessonNum]) {
                lessonGroups[lessonNum] = [];
            }
            lessonGroups[lessonNum].push(q);
        }
    });
    
    for (let i = 1; i <= unit.lessons; i++) {
        const questionCount = lessonGroups[i] ? lessonGroups[i].length : 0;
        const isCompleted = checkLessonCompleted(currentUnit, i);
        lessonButtonsHtml += `
            <button onclick="loadLesson(${i})" class="lesson-btn ${isCompleted ? 'completed' : ''}" id="lesson-btn-${i}">
                Lesson ${i}<br>
                <small>${questionCount} questions</small>
            </button>
        `;
    }
    
    questionsContainer.innerHTML = `
        <button onclick="backToUnits()" class="back-button">← Back to Units</button>
        <div class="lesson-selector">
            <h3>Unit ${currentUnit}: ${unit.name}</h3>
            <p>Select a lesson to begin:</p>
            <div class="lesson-buttons">
                ${lessonButtonsHtml}
            </div>
        </div>
    `;
}

        // Check if lesson is completed
        function checkLessonCompleted(unitNum, lessonNum) {
            const lessonQuestions = allUnitQuestions.filter(q => {
                const match = q.id.match(/L(\d+)/);
                return match && parseInt(match[1]) === lessonNum;
            });
            
            if (lessonQuestions.length === 0) return false;
            
            return lessonQuestions.every(q => isQuestionAnswered(q.id));
        }

        // Load lesson
        window.loadLesson = function(lessonNumber) {
            currentLesson = lessonNumber;

            // TASK 4.1: Clean up activity listeners before loading new lesson
            cleanupActivityTracking();

            // Handle both numeric lessons and 'PC'
            if (lessonNumber === 'PC') {
                currentQuestions = allUnitQuestions.filter(q => q.id.includes('-PC-'));
            } else {
                const lessonNum = parseInt(lessonNumber);
                currentQuestions = allUnitQuestions.filter(q => {
                    if (q.id.includes('-PC-')) return false; // Exclude PC questions
                    const match = q.id.match(/U\d+-L(\d+)-/);
                    return match && parseInt(match[1]) === lessonNum;
                });
            }

            if (currentQuestions.length === 0) {
                showMessage(`No questions found for Lesson ${lessonNumber}`, 'error');
                return;
            }

            console.log(`Loading lesson ${lessonNumber} with ${currentQuestions.length} questions`); // Debug
            renderQuiz();
        }

        // Back to units
        window.backToUnits = function() {
            // TASK 4.1: Clean up activity listeners before returning to units
            cleanupActivityTracking();

            // Clear any existing charts
            Object.values(chartInstances).forEach(chart => {
                if (chart && typeof chart.destroy === 'function') {
                    chart.destroy();
                }
            });
            chartInstances = {};
            currentQuestions = [];
            allUnitQuestions = [];
            currentUnit = null;
            currentLesson = null;

            // Go to unit menu
            renderUnitMenu();
        }

        // Back to lessons
        window.backToLessons = function() {
            // Clear any existing charts
            Object.values(chartInstances).forEach(chart => {
                if (chart && typeof chart.destroy === 'function') {
                    chart.destroy();
                }
            });
            chartInstances = {};
            currentQuestions = [];
            currentLesson = null;

            // Re-detect the unit structure from allUnitQuestions
            const unitInfo = detectUnitAndLessons(allUnitQuestions);

            // Call renderLessonSelector with the unitInfo
            renderLessonSelector(unitInfo);
        }

        // Render quiz
        function renderQuiz() {
            const questionsContainer = document.getElementById('questionsContainer');
            
            questionsContainer.innerHTML = `
                <button onclick="backToLessons()" class="back-button">← Back to Lessons</button>
                <div class="app-controls">
                    <div style="flex: 1;">
                        <strong>Unit ${currentUnit}, Lesson ${currentLesson}</strong> - ${currentQuestions.length} questions
                    </div>
                </div>

                <div id="questions-list"></div>
                <div class="loading-msg" id="loading-msg" style="display:none;">Loading questions...</div>
            `;
            
            const questionsList = document.getElementById('questions-list');
            
            // Show loading message
            document.getElementById('loading-msg').style.display = 'block';
            
            // Render all questions for the lesson with a small delay for animation
            setTimeout(() => {
                currentQuestions.forEach((question, index) => {
                    const questionHtml = renderQuestion(question, index);
                    questionsList.insertAdjacentHTML('beforeend', questionHtml);
                });
                
                document.getElementById('loading-msg').style.display = 'none';
                
                // Load saved progress
                loadProgress();
                
                // Render MathJax
                if (window.MathJax) {
                    MathJax.typesetPromise().catch(e => console.log('MathJax error:', e));
                }
                
                // Render charts for visible questions
                setTimeout(renderVisibleCharts, 100);

                // TASK 3.3: Set up activity tracking for question interactions
                setTimeout(setupQuestionActivityTracking, 150);
            }, 100);
        }

        /**
         * TASK 3.3: Sets up event listeners for tracking user activity on questions
         * TASK 4.1: Now tracks listeners for cleanup (memory leak prevention)
         */
        function setupQuestionActivityTracking() {
            if (!currentQuestions || currentQuestions.length === 0) return;

            // TASK 4.1: Clean up old listeners first
            cleanupActivityTracking();

            currentQuestions.forEach(question => {
                const questionId = question.id;

                // Track radio button clicks (MC questions)
                const radios = document.querySelectorAll(`input[name="choice-${questionId}"]`);
                radios.forEach(radio => {
                    const listener = () => { if (typeof updateUserActivity === 'function') { updateUserActivity('answering', questionId); } };
                    radio.addEventListener('change', listener);
                    // TASK 4.1: Track for cleanup
                    activityListeners.push({ element: radio, type: 'change', listener });
                });

                // Track textarea focus (FRQ questions) - debounced
                const frqTextarea = document.getElementById(`frq-${questionId}`);
                if (frqTextarea) {
                    let focusTimeout = null;
                    const focusListener = () => {
                        if (focusTimeout) clearTimeout(focusTimeout);
                        focusTimeout = setTimeout(() => {
                            if (typeof updateUserActivity === 'function') { updateUserActivity('answering', questionId); }
                        }, 1000);
                    };
                    const blurListener = () => {
                        if (focusTimeout) clearTimeout(focusTimeout);
                    };

                    frqTextarea.addEventListener('focus', focusListener);
                    frqTextarea.addEventListener('blur', blurListener);

                    // TASK 4.1: Track for cleanup
                    activityListeners.push({ element: frqTextarea, type: 'focus', listener: focusListener });
                    activityListeners.push({ element: frqTextarea, type: 'blur', listener: blurListener });
                }

                // Track reasoning textarea focus - debounced
                const reasonTextarea = document.getElementById(`reason-${questionId}`);
                if (reasonTextarea) {
                    let focusTimeout = null;
                    const focusListener = () => {
                        if (focusTimeout) clearTimeout(focusTimeout);
                        focusTimeout = setTimeout(() => {
                            if (typeof updateUserActivity === 'function') { updateUserActivity('answering', questionId); }
                        }, 1000);
                    };
                    const blurListener = () => {
                        if (focusTimeout) clearTimeout(focusTimeout);
                    };

                    reasonTextarea.addEventListener('focus', focusListener);
                    reasonTextarea.addEventListener('blur', blurListener);

                    // TASK 4.1: Track for cleanup
                    activityListeners.push({ element: reasonTextarea, type: 'focus', listener: focusListener });
                    activityListeners.push({ element: reasonTextarea, type: 'blur', listener: blurListener });
                }
            });

            console.log(`🐷 Activity tracking set up for ${currentQuestions.length} questions (${activityListeners.length} listeners)`);
        }

        /**
         * TASK 4.1: Cleanup function to remove all activity tracking listeners
         * Prevents memory leaks when switching lessons/units
         */
        function cleanupActivityTracking() {
            activityListeners.forEach(({ element, type, listener }) => {
                if (element) {
                    element.removeEventListener(type, listener);
                }
            });
            activityListeners = [];
            console.log('🐷 Activity tracking listeners cleaned up');
        }

        // Render question
        function renderQuestion(question, index) {
            const questionNumber = index + 1;
            const isAnswered = isQuestionAnswered(question.id);
            const attempts = getAttemptCount(question.id);
            const canRetryQuestion = canRetry(question.id);

            // Check if answer is correct (for styling)
            let isCorrect = false;
            if (isAnswered) {
                const correctAnswer = getCorrectAnswer(question.id);
                const userAnswer = classData.users[currentUsername]?.answers?.[question.id];
                const userAnswerValue = userAnswer?.value || userAnswer;
                if (correctAnswer && userAnswerValue) {
                    isCorrect = (userAnswerValue.toString().toLowerCase().trim() === correctAnswer.toString().toLowerCase().trim());
                }
            }

            // Create two-column layout structure
            let html = `
                <div class="quiz-container two-column-layout" data-question-id="${question.id}" data-question-number="${questionNumber}">
                    <div class="question-main-column">
                        <div class="question-header ${isCorrect ? 'correct-answer' : ''}">
                            <span>Question ${questionNumber}</span>
                            ${isAnswered ? (isCorrect ? '<span style="color: #f39c12;">⭐ Correctly Answered</span>' : '<span style="color: #a5d6a7;">✓ Answered</span>') : ''}
                        </div>
                        <div class="question-id">ID: ${question.id || 'N/A'}</div>
                        <div class="question-prompt">${question.prompt || 'No prompt provided'}</div>
            `;

            // Render question attachments (charts, tables, images) in main column
            if (question.attachments) {
                html += renderAttachments(question.attachments, question.id);
            }

            // Handle MCQ in main column
            if (question.type === 'multiple-choice') {
                const choices = question.choices || question.attachments?.choices || [];
                const savedAnswer = classData.users[currentUsername]?.answers?.[question.id];
                const isDisabled = isAnswered && !canRetryQuestion;

                html += '<div class="choices">';
                choices.forEach(choice => {
                    const isSelected = savedAnswer?.value === choice.key || savedAnswer === choice.key;
                    html += `
                        <div class="choice ${isSelected ? 'selected' : ''} ${isDisabled ? 'disabled' : ''}">
                            <label>
                                <input type="radio"
                                       name="choice-${question.id}"
                                       value="${choice.key}"
                                       ${isSelected ? 'checked' : ''}
                                       ${isDisabled ? 'disabled' : ''}>
                                <span class="choice-key">${choice.key}.</span>
                                <span>${choice.value}</span>
                            </label>
                        </div>
                    `;
                });
                html += '</div>';
            }

            // Handle FRQ in main column
            if (question.type === 'free-response') {
                const savedAnswer = classData.users[currentUsername]?.answers?.[question.id];
                const isDisabled = isAnswered && !canRetryQuestion;
                html += `
                    <div class="answer-section">
                        <textarea
                            id="frq-${question.id}"
                            class="frq-textarea"
                            placeholder="Enter your complete response here..."
                            ${isDisabled ? 'disabled' : ''}
                            style="width: 100%; min-height: 200px; padding: 10px; border: 2px solid #ddd;"
                        >${savedAnswer?.value || savedAnswer || ''}</textarea>
                    </div>
                `;
            }

            // Add reasoning section in main column
            html += `
                        <div class="answer-section">
                            <div class="reason-wrapper">
                                <label class="reason-label">
                                    ${attempts > 0 && !canRetryQuestion ?
                                        'Your explanation (required for retry):' :
                                        'Explain your reasoning (optional but enables retry):'}
                                </label>
                                <textarea
                                    id="reason-${question.id}"
                                    class="reason-textarea ${attempts > 0 && canRetryQuestion ? 'required' : ''}"
                                    placeholder="${attempts > 0 && !canRetryQuestion ?
                                        'Previous attempt did not include reasoning. Add reasoning to enable retry.' :
                                        'Explain why you chose this answer...'}"
                                    ${!canRetryQuestion && attempts >= 3 ? 'disabled' : ''}
                                >${classData.users[currentUsername]?.reasons?.[question.id] || ''}</textarea>
                            </div>
                            <div>
                                <button
                                    id="submit-${question.id}"
                                    class="submit-button"
                                    onclick="submitAnswer('${question.id}', '${question.type}')"
                                    ${!canRetryQuestion && isAnswered ? 'disabled' : ''}
                                >
                                    ${isAnswered ? (canRetryQuestion ? 'Update Answer' : 'Max Attempts Reached') : 'Submit Answer'}
                                </button>

                                ${isAnswered && !canRetryQuestion && attempts < 3 && !(classData.users[currentUsername]?.reasons?.[question.id]?.trim()) ? `
                                    <button
                                        id="add-explanation-${question.id}"
                                        class="add-explanation-button"
                                        onclick="addExplanationToRetry('${question.id}')"
                                        style="margin-left: 10px; background: #28a745; color: white;"
                                    >
                                        Add Explanation to Retry
                                    </button>
                                ` : ''}

                                <span id="error-${question.id}" class="error-msg"></span>
                                <span id="success-${question.id}" class="success-msg"></span>
                            </div>
                        </div>
                    </div>

                    <!-- RIGHT COLUMN: Peer Reasoning Sidebar -->
                    <div class="peer-sidebar">
                        <div class="peer-sidebar-content">
                            <!-- Peer reasoning section (main focus) -->
                            <div class="peer-reasoning-section" id="peer-reasoning-${question.id}">
                                <div class="peer-reasoning-header">
                                    <h4>🤝 Peer Responses</h4>
                                    <span class="peer-count" id="peer-count-${question.id}">Loading...</span>
                                </div>
                                <div class="peer-reasoning-content" id="peer-reasoning-content-${question.id}">
                                    ${isAnswered ? '<div class="peer-loading">Loading peer responses...</div>' : '<div class="peer-hint">Answer the question to see peer responses</div>'}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // If this question is already answered, populate peer responses immediately
            setTimeout(() => {
                if (isAnswered) {
                    populatePeerResponses(question.id, question.type);

                    // Check if answer was correct and should show College Board explanation
                    const userAnswer = classData.users[currentUsername]?.answers?.[question.id];
                    const userReason = classData.users[currentUsername]?.reasons?.[question.id];
                    const correctAnswer = getCorrectAnswer(question.id);

                    if (userAnswer && correctAnswer) {
                        const userValue = userAnswer.value || userAnswer;
                        const isCorrect = (userValue.toString().toLowerCase().trim() === correctAnswer.toString().toLowerCase().trim());
                        const hasExplanation = (userReason && userReason.trim().length > 0);

                        console.log(`DEBUG: On load - isCorrect: ${isCorrect}, hasExplanation: ${hasExplanation}`);

                        // Show College Board explanation if conditions are met
                        if (isCorrect && hasExplanation) {
                            displayCollegeBoardExplanation(question.id);
                            // Also change textarea border to gold
                            const reasonTextarea = document.getElementById(`reason-${question.id}`);
                            if (reasonTextarea) {
                                reasonTextarea.style.borderColor = '#f39c12';
                                reasonTextarea.style.boxShadow = '0 0 0 0.2rem rgba(243, 156, 18, 0.25)';
                            }
                        }
                    }
                }
            }, 100);

            return html;
        }

        // Populate peer reasoning section with peer response cards
        function populatePeerReasoning(questionId, contributors) {
            const peerReasoningContent = document.getElementById(`peer-reasoning-content-${questionId}`);
            const peerCountSpan = document.getElementById(`peer-count-${questionId}`);

            if (!peerReasoningContent) return;

            // Filter out current user's responses for peer display
            const peerResponses = contributors.filter(c => c.username !== currentUsername);

            // Update peer count
            if (peerCountSpan) {
                peerCountSpan.textContent = peerResponses.length > 0 ? `${peerResponses.length} peers` : 'No peers yet';
            }

            if (peerResponses.length === 0) {
                peerReasoningContent.innerHTML = '<div class="peer-hint">No peer responses yet. Be the first to answer!</div>';
                return;
            }

            // Calculate vote scores for each response (only "helpful" votes count for ranking)
            peerResponses.forEach(peer => {
                peer.helpfulVotes = getVoteCount(questionId, peer.username, 'helpful');
                peer.unclearVotes = getVoteCount(questionId, peer.username, 'unclear');
                peer.contradictsVotes = getVoteCount(questionId, peer.username, 'contradicts');
                peer.totalVotes = peer.helpfulVotes + peer.unclearVotes + peer.contradictsVotes;
                peer.voteScore = peer.helpfulVotes; // Use helpful votes for ranking
            });

            // Sort responses by helpful votes (highest first), then by reasoning
            peerResponses.sort((a, b) => {
                if (b.voteScore !== a.voteScore) return b.voteScore - a.voteScore;
                const aHasReason = a.reason && a.reason.trim().length > 0;
                const bHasReason = b.reason && b.reason.trim().length > 0;
                if (aHasReason && !bHasReason) return -1;
                if (!aHasReason && bHasReason) return 1;
                return 0;
            });

            // Calculate max votes for percentage bars
            const maxVotes = Math.max(...peerResponses.map(p => p.helpfulVotes), 1);
            const totalHelpfulVotes = peerResponses.reduce((sum, p) => sum + p.helpfulVotes, 0);

            // Check if answer key has been revealed for this question
            const answerKeySection = document.getElementById(`answer-key-${questionId}`);
            const cbSection = document.getElementById(`college-board-explanation-${questionId}`);
            const answerKeyRevealed = (answerKeySection && answerKeySection.style.display === 'block') ||
                                    (cbSection && cbSection.style.display === 'block');

            console.log(`DEBUG populatePeerReasoning: ${questionId} - answerKeySection exists: ${!!answerKeySection}, cbSection exists: ${!!cbSection}`);
            console.log(`DEBUG populatePeerReasoning: ${questionId} - answerKeyRevealed: ${answerKeyRevealed}`);

            let html = '';
            peerResponses.forEach((peer, index) => {
                const hasReason = peer.reason && peer.reason.trim().length > 0;

                // Determine if this peer's answer is correct (only if answer key is revealed)
                let isCorrect = false;
                const isCollegeBoard = peer.username === 'college_board';

                if (answerKeyRevealed || isCollegeBoard) {
                    const correctAnswer = getCorrectAnswer(questionId);
                    if (correctAnswer && (peer.choice || peer.response)) {
                        const peerAnswer = peer.choice || peer.response;
                        isCorrect = (peerAnswer.toString().toLowerCase().trim() === correctAnswer.toString().toLowerCase().trim());
                    }
                }

                // Determine ranking badge and consensus level
                let rankBadge = '';
                let consensusLevel = '';
                if (peer.helpfulVotes > 0 && !isCollegeBoard) {
                    if (index === 0 && peer.helpfulVotes >= 3) {
                        rankBadge = '🥇 #1';
                        consensusLevel = 'high';
                    } else if (index === 1 && peer.helpfulVotes >= 2) {
                        rankBadge = '🥈 #2';
                        consensusLevel = 'medium';
                    } else if (index === 2 && peer.helpfulVotes >= 1) {
                        rankBadge = '🥉 #3';
                        consensusLevel = 'low';
                    }
                }

                // Calculate vote percentage
                const votePercentage = totalHelpfulVotes > 0 ? (peer.helpfulVotes / totalHelpfulVotes * 100).toFixed(0) : 0;
                const barWidth = maxVotes > 0 ? (peer.helpfulVotes / maxVotes * 100) : 0;

                // Check if current user voted on this response
                const userVote = classData.users[currentUsername]?.votes?.[questionId]?.[peer.username];
                const votedHelpful = userVote?.type === 'helpful';
                const votedUnclear = userVote?.type === 'unclear';
                const votedContradicts = userVote?.type === 'contradicts';

                console.log(`DEBUG: Peer ${peer.username} - answer: ${peer.choice || peer.response}, isCorrect: ${isCorrect}, answerKeyRevealed: ${answerKeyRevealed}`);

                html += `
                    <div class="peer-response-card ${isCorrect ? 'correct' : 'incorrect'} ${isCollegeBoard ? 'college-board-official' : ''}" data-consensus="${consensusLevel}">
                        ${rankBadge ? `<div class="answer-rank">${rankBadge}</div>` : ''}
                        <div class="peer-name">
                            ${isCollegeBoard ? '🏛️ College Board (Official)' : peer.username}
                            ${isCorrect || isCollegeBoard ? '✓' : ''}
                        </div>
                        <div class="peer-answer"><strong>Answer:</strong> ${peer.choice || peer.response}</div>
                        ${hasReason ? `
                            <div class="peer-reasoning-text ${isCollegeBoard ? 'official-explanation' : ''}">${peer.reason}</div>
                        ` : '<div class="peer-reasoning-text" style="color: #999; font-style: italic;">No explanation provided</div>'}

                        ${peer.helpfulVotes > 0 ? `
                            <div class="vote-bar-container">
                                <div class="vote-bar" style="width: ${barWidth}%"></div>
                            </div>
                        ` : ''}

                        ${peer.response && !isCollegeBoard ? `
                            <div class="peer-voting-buttons">
                                <button onclick="voteFRQ('${questionId}', '${peer.username}', 'helpful')" class="vote-btn helpful ${votedHelpful ? 'voted' : ''}">
                                    <i class="fas fa-thumbs-up"></i>
                                    <span class="vote-count">${peer.helpfulVotes}</span>
                                    ${peer.helpfulVotes > 0 ? `<span class="vote-percentage">(${votePercentage}%)</span>` : ''}
                                </button>
                                ${votedHelpful ? '<span class="your-vote-badge">Your vote!</span>' : ''}
                                <button onclick="voteFRQ('${questionId}', '${peer.username}', 'unclear')" class="vote-btn unclear ${votedUnclear ? 'voted' : ''}">
                                    <i class="fas fa-question-circle"></i>
                                    <span class="vote-count">${peer.unclearVotes}</span>
                                </button>
                                ${votedUnclear ? '<span class="your-vote-badge unclear">Your vote</span>' : ''}
                                <button onclick="voteFRQ('${questionId}', '${peer.username}', 'contradicts')" class="vote-btn contradicts ${votedContradicts ? 'voted' : ''}">
                                    <i class="fas fa-exclamation-triangle"></i>
                                    <span class="vote-count">${peer.contradictsVotes}</span>
                                </button>
                                ${votedContradicts ? '<span class="your-vote-badge contradicts">Your vote</span>' : ''}
                            </div>
                        ` : ''}
                    </div>
                `;
            });

            peerReasoningContent.innerHTML = html;
        }

        // Gather peer responses and populate reasoning section
        function populatePeerResponses(questionId, questionType) {
            const contributors = [];

            // Gather all user responses for this question
            for (let username in classData.users) {
                const userAnswer = classData.users[username].answers?.[questionId];
                if (userAnswer) {
                    const response = userAnswer.value || userAnswer;
                    const reason = classData.users[username].reasons?.[questionId] || '';

                    if (questionType === 'multiple-choice') {
                        contributors.push({
                            username: username,
                            choice: response,
                            reason: reason
                        });
                    } else {
                        // FRQ
                        contributors.push({
                            username: username,
                            response: response,
                            reason: reason
                        });
                    }

                    // Add peer pig if not already present
                    if (window.pigManager && username !== currentUsername) {
                        window.pigManager.addPeerPig(username);
                    }
                }
            }

            // Call the populate function with the gathered data
            populatePeerReasoning(questionId, contributors);
        }

        // Render attachments (charts, tables, images)
        function renderAttachments(attachments, questionId) {
            let html = '';

            // Handle charts
            if (attachments.chartType) {
                html += renderChart(attachments, questionId);
            }

            // Handle tables
            if (attachments.table) {
                html += renderTable(attachments.table);
            }

            // Handle images
            if (attachments.image) {
                html += `
                    <div class="image-container">
                        <img src="${attachments.image}" alt="Question image" style="max-width: 100%; height: auto;">
                    </div>
                `;
            }

            return html;
        }

        // Render attachments for sidebar (with modified sizing)
        function renderAttachmentsForSidebar(attachments, questionId) {
            let html = '';

            // Handle charts in sidebar
            if (attachments.chartType) {
                html += `
                    <div class="sidebar-chart-container">
                        <h5>📊 Data Visualization</h5>
                        ${renderChart(attachments, questionId + '-sidebar')}
                    </div>
                `;
            }

            // Handle tables in sidebar
            if (attachments.table) {
                html += `
                    <div class="sidebar-table-container">
                        <h5>📋 Data Table</h5>
                        ${renderTable(attachments.table)}
                    </div>
                `;
            }

            // Handle images in sidebar
            if (attachments.image) {
                html += `
                    <div class="sidebar-image-container">
                        <h5>🖼️ Reference Image</h5>
                        <img src="${attachments.image}" alt="Question image" style="max-width: 100%; height: auto; border-radius: 8px;">
                    </div>
                `;
            }

            return html;
        }
        
        // Render chart placeholder (actual rendering happens later)
          // FIXED: Table rendering to handle both object and array formats
          function renderTable(table) {
              if (!table) return '';

              let tableHtml = '<div class="table-container"><table>';

              // Handle object format (with headers and rows properties)
              if (table.headers && table.rows) {
                  // Render headers
                  tableHtml += '<thead><tr>';
                  table.headers.forEach(header => {
                      tableHtml += `<th>${header}</th>`;
                  });
                  tableHtml += '</tr></thead>';

                  // Render rows
                  if (table.rows && table.rows.length > 0) {
                      tableHtml += '<tbody>';
                      table.rows.forEach(row => {
                          tableHtml += '<tr>';
                          row.forEach(cell => {
                              tableHtml += `<td>${cell}</td>`;
                          });
                          tableHtml += '</tr>';
                      });
                      tableHtml += '</tbody>';
                  }
              }
              // Handle array format (legacy)
              else if (Array.isArray(table) && table.length > 0) {
                  const headers = table[0];
                  const rows = table.slice(1);

                  // Headers
                  tableHtml += '<thead><tr>';
                  headers.forEach(header => {
                      tableHtml += `<th>${header}</th>`;
                  });
                  tableHtml += '</tr></thead>';

                  // Rows
                  if (rows.length > 0) {
                      tableHtml += '<tbody>';
                      rows.forEach(row => {
                          tableHtml += '<tr>';
                          row.forEach(cell => {
                              tableHtml += `<td>${cell}</td>`;
                          });
                          tableHtml += '</tr>';
                      });
                      tableHtml += '</tbody>';
                  }
              }

              tableHtml += '</table></div>';

              return tableHtml;
          }
// Complete chart rendering function
function renderChartNow(chartId) {
    const canvas = document.getElementById(chartId);
    if (!canvas) return;

    // FIX: Check if chart already exists and destroy it
    if (chartInstances[chartId]) {
        chartInstances[chartId].destroy();
        delete chartInstances[chartId];
    }

    const chartData = window.pendingCharts[chartId];
    if (!chartData) return;

    const ctx = canvas.getContext('2d');

    // FIX: Set canvas parent height to prevent infinite expansion
    canvas.parentElement.style.height = '400px';
    canvas.parentElement.style.position = 'relative';

    const config = chartData.chartConfig || {};
    
    // Bar/Histogram charts
    if (chartData.chartType === 'bar' || chartData.chartType === 'histogram') {
        const colorPalette = ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40'];
        const datasets = chartData.series.map((series, index) => ({
            label: series.name,
            data: series.values,
            backgroundColor: colorPalette[index % colorPalette.length],
            borderColor: colorPalette[index % colorPalette.length],
            borderWidth: 1
        }));
        
        const isHistogram = chartData.chartType === 'histogram';
        
        chartInstances[chartId] = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: chartData.xLabels || [],
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: datasets.length > 1
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        min: config.yAxis?.min,
                        max: config.yAxis?.max,
                        title: {
                            display: true,
                            text: config.yAxis?.title || chartData.yLabel || 'Value'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: config.xAxis?.title || chartData.xLabel || 'Category'
                        }
                    }
                }
            }
        });
    }
    
    // Pie chart
    else if (chartData.chartType === 'pie') {
        const seriesData = chartData.series[0].values;
        const labels = seriesData.map(item => item.name);
        const values = seriesData.map(item => item.value);
        
        chartInstances[chartId] = new Chart(ctx, {
            type: 'pie',
            data: {
                labels: labels,
                datasets: [{
                    data: values,
                    backgroundColor: ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF'],
                    borderWidth: 2,
                    borderColor: '#fff'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'bottom'
                    }
                }
            }
        });
    }
    
    // Scatter plot
    else if (chartData.chartType === 'scatter') {
        chartInstances[chartId] = new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Data Points',
                    data: chartData.points,
                    backgroundColor: '#36A2EB',
                    borderColor: '#36A2EB',
                    pointRadius: 4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'linear',
                        position: 'bottom',
                        min: config.xAxis?.min,
                        max: config.xAxis?.max,
                        title: {
                            display: true,
                            text: config.xAxis?.title || chartData.xLabel || 'X Variable'
                        }
                    },
                    y: {
                        min: config.yAxis?.min,
                        max: config.yAxis?.max,
                        title: {
                            display: true,
                            text: config.yAxis?.title || chartData.yLabel || 'Y Variable'
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    }
                }
            }
        });
    }
    
    // Dotplot
    else if (chartData.chartType === 'dotplot') {
        const valueFrequency = {};
        chartData.values.forEach(value => {
            valueFrequency[value] = (valueFrequency[value] || 0) + 1;
        });
        
        const dotplotData = [];
        for (const [value, frequency] of Object.entries(valueFrequency)) {
            for (let i = 1; i <= frequency; i++) {
                dotplotData.push({
                    x: parseFloat(value),
                    y: i
                });
            }
        }
        
        chartInstances[chartId] = new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Data Points',
                    data: dotplotData,
                    backgroundColor: '#36A2EB',
                    borderColor: '#36A2EB',
                    pointRadius: 4,
                    showLine: false
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'linear',
                        min: config.xAxis?.min,
                        max: config.xAxis?.max,
                        title: {
                            display: true,
                            text: config.xAxis?.title || 'Value'
                        }
                    },
                    y: {
                        min: 0,
                        max: Math.max(...Object.values(valueFrequency)) + 1,
                        display: false
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    }
                }
            }
        });
    }
    
    // Boxplot
    else if (chartData.chartType === 'boxplot') {
        const boxplotData = config.boxplotData || {};
        const { Q1, Q3, median, min, max } = boxplotData;
        
        // Create a simple representation using bar chart
        chartInstances[chartId] = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: ['Min', 'Q1', 'Median', 'Q3', 'Max'],
                datasets: [{
                    label: 'Five Number Summary',
                    data: [min, Q1, median, Q3, max],
                    backgroundColor: '#36A2EB'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: false,
                        title: {
                            display: true,
                            text: config.xAxis?.title || 'Value'
                        }
                    }
                }
            }
        });
    }
}

// Complete table rendering
function renderTable(table) {
    if (!table) return '';
    
    let html = '<div class="table-container"><table>';
    
    // Handle object format with headers and rows
    if (table.headers && table.rows) {
        html += '<thead><tr>';
        table.headers.forEach(header => {
            html += `<th>${header}</th>`;
        });
        html += '</tr></thead><tbody>';
        
        table.rows.forEach(row => {
            html += '<tr>';
            row.forEach(cell => {
                html += `<td>${cell}</td>`;
            });
            html += '</tr>';
        });
        html += '</tbody>';
    }
    // Handle array format (legacy)
    else if (Array.isArray(table) && table.length > 0) {
        const headers = table[0];
        const rows = table.slice(1);
        
        html += '<thead><tr>';
        headers.forEach(header => {
            html += `<th>${header}</th>`;
        });
        html += '</tr></thead>';
        
        if (rows.length > 0) {
            html += '<tbody>';
            rows.forEach(row => {
                html += '<tr>';
                row.forEach(cell => {
                    html += `<td>${cell}</td>`;
                });
                html += '</tr>';
            });
            html += '</tbody>';
        }
    }
    
    html += '</table></div>';
    return html;
}

// Updated renderAttachments to handle multiple charts
function renderAttachments(attachments, questionId) {
    let html = '';
    
    // Handle multiple charts
    if (attachments.charts && Array.isArray(attachments.charts)) {
        attachments.charts.forEach((chart, idx) => {
            html += renderChart(chart, `${questionId}-chart-${idx}`);
        });
    }
    // Handle single chart
    else if (attachments.chartType) {
        html += renderChart(attachments, `${questionId}-chart`);
    }
    
    // Handle tables
    if (attachments.table) {
        html += renderTable(attachments.table);
    }
    
    // Handle images
    if (attachments.image) {
        const imageAlt = attachments.imageAlt || 'Question image';
        const imageCaption = attachments.imageCaption || '';
        html += `
            <div class="image-container">
                <img src="${attachments.image}" alt="${imageAlt}" style="max-width: 100%; height: auto;">
                ${imageCaption ? `<div style="text-align: center; font-style: italic; color: #666; margin-top: 5px;">${imageCaption}</div>` : ''}
            </div>
        `;
    }
    
    // Handle multiple images
    if (attachments.images && Array.isArray(attachments.images)) {
        html += '<div style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;">';
        attachments.images.forEach(img => {
            html += `
                <div style="flex: 1; min-width: 200px; max-width: 400px;">
                    <img src="${img.url || img}" alt="${img.alt || 'Image'}" style="width: 100%; height: auto;">
                    ${img.caption ? `<div style="text-align: center; font-style: italic; color: #666; margin-top: 5px;">${img.caption}</div>` : ''}
                </div>
            `;
        });
        html += '</div>';
    }
    
    return html;
}

        // Render visible charts
        function renderVisibleCharts() {
            const chartContainers = document.querySelectorAll('[data-chart-id]');
            chartContainers.forEach(container => {
                const chartId = container.dataset.chartId;
                if (window.pendingCharts && window.pendingCharts[chartId]) {
                    renderChartNow(chartId);
                    delete window.pendingCharts[chartId];
                }
            });
        }

        // Actually render a chart
        function renderChartNow(chartId) {
            const canvas = document.getElementById(chartId);
            if (!canvas) return;

            // FIX: Check if chart already exists and destroy it
            if (chartInstances[chartId]) {
                chartInstances[chartId].destroy();
                delete chartInstances[chartId];
            }

            const chartData = window.pendingCharts[chartId];
            if (!chartData) return;

            const ctx = canvas.getContext('2d');

            // FIX: Set canvas parent height to prevent infinite expansion
            canvas.parentElement.style.height = '400px';
            canvas.parentElement.style.position = 'relative';

            const config = chartData.chartConfig || {};
            
            // Simple bar/histogram chart
            if (chartData.chartType === 'bar' || chartData.chartType === 'histogram') {
                const datasets = chartData.series.map(series => ({
                    label: series.name,
                    data: series.values,
                    backgroundColor: '#36A2EB',
                    borderColor: '#36A2EB',
                    borderWidth: 1
                }));
                
                chartInstances[chartId] = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: chartData.xLabels || [],
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: config.yAxis?.title || 'Value'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: config.xAxis?.title || 'Category'
                                }
                            }
                        }
                    }
                });
            }
            // Add other chart types as needed
        }

        // Submit answer
        window.submitAnswer = function(questionId, questionType) {
            if (!currentUsername) {
                showMessage('Please enter your username first!', 'error');
                return;
            }

            const errorSpan = document.getElementById(`error-${questionId}`);
            const successSpan = document.getElementById(`success-${questionId}`);
            
            // Clear previous messages
            if (errorSpan) {
                errorSpan.textContent = '';
                errorSpan.classList.remove('show');
            }
            if (successSpan) {
                successSpan.textContent = '';
                successSpan.classList.remove('show');
            }

            // Get current attempt count
            const attempts = getAttemptCount(questionId);
            
            // Check if can retry
            if (attempts > 0 && !canRetry(questionId)) {
                if (errorSpan) {
                    errorSpan.textContent = attempts >= 3 ? 
                        'Maximum attempts reached (3).' : 
                        'Please provide reasoning with your previous answer to enable retry.';
                    errorSpan.classList.add('show');
                }
                return;
            }

            // Get answer value
            let value = '';
            if (questionType === 'multiple-choice') {
                const selectedRadio = document.querySelector(`input[name="choice-${questionId}"]:checked`);
                if (!selectedRadio) {
                    if (errorSpan) {
                        errorSpan.textContent = 'Please select an answer.';
                        errorSpan.classList.add('show');
                    }
                    return;
                }
                value = selectedRadio.value;
            } else {
                const textarea = document.getElementById(`frq-${questionId}`);
                if (!textarea || !textarea.value.trim()) {
                    if (errorSpan) {
                        errorSpan.textContent = 'Please enter a response.';
                        errorSpan.classList.add('show');
                    }
                    return;
                }
                value = textarea.value.trim();
            }

            // Get reason
            const reasonTextarea = document.getElementById(`reason-${questionId}`);
            const reason = reasonTextarea ? reasonTextarea.value.trim() : '';

            // If this is a retry (attempts > 0), reason is required
            if (attempts > 0 && !reason) {
                if (errorSpan) {
                    errorSpan.textContent = 'Reasoning is required for retry attempts.';
                    errorSpan.classList.add('show');
                }
                reasonTextarea.classList.add('required');
                reasonTextarea.focus();
                return;
            }

            // Save answer
            if (!classData.users[currentUsername]) {
                classData.users[currentUsername] = {
                    answers: {},
                    reasons: {},
                    timestamps: {},
                    attempts: {}
                };
            }

            // Create timestamp as number for consistency
            const timestampNow = Date.now();

            classData.users[currentUsername].answers[questionId] = {
                value: value,
                timestamp: timestampNow
            };
            classData.users[currentUsername].reasons[questionId] = reason;
            classData.users[currentUsername].timestamps[questionId] = new Date().toISOString();
            classData.users[currentUsername].attempts[questionId] = attempts + 1;

            saveClassData();

            // Also save to answers_username format for compatibility
            const userAnswersKey = `answers_${currentUsername}`;
            const userAnswers = JSON.parse(localStorage.getItem(userAnswersKey) || '{}');
            userAnswers[questionId] = {
                value: value,
                timestamp: timestampNow
            };
            localStorage.setItem(userAnswersKey, JSON.stringify(userAnswers));

            // Sync to Supabase if turbo mode is active
            if (turboModeActive) {
                // PHASE 2 OPTIMIZATION: Use batching queue instead of immediate sync
                if (window.submitAnswerViaRailway) {
                    // Railway has its own batching, use it directly
                    window.submitAnswerViaRailway(currentUsername, questionId, value, timestampNow)
                        .then(success => {
                            if (success) {
                                console.log(`✅ Answer synced via Railway for ${questionId}`);
                                updatePeerDataTimestamp();
                            }
                        })
                        .catch(error => {
                            console.log(`⚠️ Failed to sync answer via Railway: ${error.message}`);
                        });
                } else {
                    // Use batching queue for Supabase
                    queueAnswerForSync(currentUsername, questionId, value, timestampNow);
                    console.log(`✅ Answer queued for batch sync: ${questionId}`);
                }
            }

            // Broadcast pig activity
            if (window.pigManager) {
                // Trigger celebration for current user's pig (if it exists)
                if (window.pigSprite) {
                    window.pigSprite.jump();
                }

                // Broadcast activity to peer pigs system
                // This will be picked up when peers sync data
                console.log(`🐷 Activity: ${currentUsername} submitted answer to ${questionId}`);
            }

            // TASK 3.3: Track activity state for real-time sync (guarded)
            if (typeof updateUserActivity === 'function') {
                updateUserActivity('submitted', questionId);
            }

            // Update UI
            const submitBtn = document.getElementById(`submit-${questionId}`);
            const qContainer = document.querySelector(`[data-question-id="${questionId}"]`);

            // Update button
            if (submitBtn) {
                if (!canRetry(questionId)) {
                    submitBtn.textContent = 'Max Attempts Reached';
                    submitBtn.disabled = true;
                } else {
                    submitBtn.textContent = 'Update Answer';
                }
            }

            // Show success message with correctness feedback
            if (successSpan) {
                const correctAnswer = getCorrectAnswer(questionId);
                let isCorrect = false;
                if (correctAnswer && value) {
                    isCorrect = (value.toString().toLowerCase().trim() === correctAnswer.toString().toLowerCase().trim());
                }

                if (isCorrect) {
                    successSpan.textContent = '✅ Correct answer submitted!';
                    successSpan.style.color = '#27ae60';
                } else {
                    successSpan.textContent = '📝 Answer submitted successfully!';
                    successSpan.style.color = '#3498db';
                }

                successSpan.classList.add('show');
                setTimeout(() => {
                    successSpan.classList.remove('show');
                }, 3000);
            }

            // Update header to show answered
            const header = qContainer.querySelector('.question-header');
            if (header && !header.querySelector('span[style*="color"]')) {
                header.innerHTML += '<span style="color: #a5d6a7;">✓ Answered</span>';
            }

            // Show/update dotplot immediately after submission (if it exists)
            const dotplotSection = document.getElementById(`dotplot-section-${questionId}`);

            // Ensure the section is visible (only if dotplot section exists)
            if (dotplotSection && !dotplotSection.classList.contains('show')) {
                dotplotSection.classList.add('show');
                dotplotSection.style.opacity = '0';
                setTimeout(() => {
                    dotplotSection.style.transition = 'opacity 0.3s ease';
                    dotplotSection.style.opacity = '1';
                }, 10);
            }

            // Always destroy existing chart to force complete refresh
            const chartId = `dotplot-${questionId}`;
            if (chartInstances[chartId]) {
                try {
                    chartInstances[chartId].destroy();
                } catch(e) {
                    console.log('Error destroying chart:', e);
                }
                delete chartInstances[chartId];
            }

            // Clear the canvas to ensure clean slate
            const canvas = document.getElementById(chartId);
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }

            // Render the appropriate visualization with a small delay to ensure DOM is ready
            setTimeout(() => {
                if (questionType === 'multiple-choice') {
                    renderMCQDistribution(questionId);
                } else {
                    renderFRQResponses(questionId);
                }

                // Populate peer reasoning after chart rendering
                populatePeerResponses(questionId, questionType);
            }, 50);

            // Trigger answer key display logic
            const correctAnswer = getCorrectAnswer(questionId);
            console.log(`DEBUG: User answer: "${value}", Correct answer: "${correctAnswer}"`);

            let isCorrect = false;
            if (correctAnswer && value) {
                isCorrect = (value.toString().toLowerCase().trim() === correctAnswer.toString().toLowerCase().trim());
            }
            console.log(`DEBUG: Answer is ${isCorrect ? 'CORRECT' : 'INCORRECT'}`);

            const hasExplanation = (reason && reason.length > 0);
            console.log(`DEBUG: Has explanation: ${hasExplanation}`);

            displayAnswerKey(questionId, isCorrect, hasExplanation, attempts + 1);
        }

        // Show dotplot
        function showDotplot(questionId, questionType) {
    const dotplotSection = document.getElementById(`dotplot-section-${questionId}`);
    if (!dotplotSection) return;

    // Ensure the section has all required containers
    if (!document.getElementById(`dotplot-${questionId}`)) {
        dotplotSection.innerHTML = `
            <canvas id="dotplot-${questionId}" width="400" height="200"></canvas>
            <div id="consensus-${questionId}"></div>
            <div class="contributors-list" id="contributors-${questionId}"></div>
        `;
    }

    // Always destroy existing chart first to force refresh
    if (chartInstances[`dotplot-${questionId}`]) {
        chartInstances[`dotplot-${questionId}`].destroy();
        delete chartInstances[`dotplot-${questionId}`];
    }

    // Show the section with animation
    if (!dotplotSection.classList.contains('show')) {
        dotplotSection.classList.add('show');
        dotplotSection.style.opacity = '0';
        setTimeout(() => {
            dotplotSection.style.transition = 'opacity 0.3s ease';
            dotplotSection.style.opacity = '1';
        }, 10);
    }

    // Render with a small delay to ensure DOM is ready
    setTimeout(() => {
        if (questionType === 'multiple-choice') {
            renderMCQDistribution(questionId);
        } else {
            renderFRQResponses(questionId);
        }
    }, 50);
}

        // Render MCQ distribution
        function renderMCQDistribution(questionId) {
            const canvas = document.getElementById(`dotplot-${questionId}`);
            if (!canvas) return;

            // Fix canvas dimensions to prevent cropping
            const container = canvas.parentElement;
            container.style.height = '500px';  // Increased from 350px
            container.style.position = 'relative';
            container.style.overflow = 'visible';  // Changed from 'hidden' to 'visible'

            // Ensure the canvas itself has room
            canvas.style.height = '600px';  // Increased from 300px
            canvas.style.width = '100%';

            // Aggregate responses
            const choiceCounts = {};
            let totalCount = 0;
            const contributors = [];

            // Get the question to know all possible choices
            const question = currentQuestions.find(q => q.id === questionId);
            const allChoices = question?.choices || question?.attachments?.choices || [];

            // Initialize all choices with 0
            allChoices.forEach(choice => {
                choiceCounts[choice.key] = 0;
            });

            // Count actual responses
            for (let username in classData.users) {
                const userAnswer = classData.users[username].answers?.[questionId];
                if (userAnswer) {
                    const choice = userAnswer.value || userAnswer;
                    const reason = classData.users[username].reasons?.[questionId] || '';

                    choiceCounts[choice] = (choiceCounts[choice] || 0) + 1;
                    totalCount++;
                    contributors.push({
                        username: username,
                        choice: choice,
                        reason: reason
                    });
                }
            }

            // Create bar chart (like your example JSON)
            const ctx = canvas.getContext('2d');
            const choices = Object.keys(choiceCounts).sort();
            const counts = choices.map(c => choiceCounts[c] || 0);
            const relativeFrequencies = counts.map(c => totalCount > 0 ? c / totalCount : 0);

            // Destroy existing chart if any
            // Destroy existing chart if any
if (chartInstances[`dotplot-${questionId}`]) {
    chartInstances[`dotplot-${questionId}`].destroy();
    delete chartInstances[`dotplot-${questionId}`];  // Add just this line
}
            // Create bar chart with relative frequencies
            chartInstances[`dotplot-${questionId}`] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: choices,
                    datasets: [{
                        label: 'Relative Frequency',
                        data: relativeFrequencies,
                        backgroundColor: choices.map(c => {
                            // Highlight user's choice in different color
                            const userChoice = classData.users[currentUsername]?.answers?.[questionId];
                            const userChoiceValue = userChoice?.value || userChoice;
                            return c === userChoiceValue ? '#4CAF50' : '#36A2EB';
                        }),
                        borderColor: '#2196F3',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            bottom: 20
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 1,
                            ticks: {
                                stepSize: 0.1,
                                callback: function(value) {
                                    return (value * 100).toFixed(0) + '%';
                                }
                            },
                            title: {
                                display: true,
                                text: 'Relative Frequency'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Answer Choice'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed.y;
                                    const percentage = (value * 100).toFixed(1);
                                    const count = counts[context.dataIndex];
                                    return `${percentage}% (${count} of ${totalCount} responses)`;
                                }
                            }
                        }
                    }
                }
            });

            // Add consensus coloring
            const maxFreq = Math.max(...relativeFrequencies);
            const consensusDiv = document.getElementById(`consensus-${questionId}`);
            if (maxFreq >= 0.7) {
                consensusDiv.style.backgroundColor = '#e8f5e9';
                consensusDiv.style.border = '2px solid #4CAF50';
            } else if (maxFreq >= 0.6) {
                consensusDiv.style.backgroundColor = '#fff3e0';
                consensusDiv.style.border = '2px solid #ff9800';
            } else {
                consensusDiv.style.backgroundColor = '#ffebee';
                consensusDiv.style.border = '2px solid #f44336';
            }

            // Show consensus message
            if (consensusDiv) {
                if (totalCount > 1) {
                    const modeIndex = relativeFrequencies.indexOf(maxFreq);
                    const mode = choices[modeIndex];
                    const percentage = (maxFreq * 100).toFixed(0);

                    // Check for consensus (70% or more agreement)
                    if (maxFreq >= 0.7) {
                        consensusDiv.innerHTML = `
                            <div class="consensus-msg consensus">
                                ✓ Consensus reached on choice ${mode} (${percentage}% agreement)
                            </div>
                        `;
                    } else {
                        consensusDiv.innerHTML = `
                            <div class="consensus-msg no-consensus">
                                No consensus yet - highest agreement: ${mode} at ${percentage}%
                            </div>
                        `;
                    }
                } else {
                    consensusDiv.innerHTML = `
                        <div class="consensus-msg no-consensus">
                            You're the first to answer! Import class data to see peer responses.
                        </div>
                    `;
                }
            }

            // Show contributors with their choices and reasons
            const contributorsDiv = document.getElementById(`contributors-${questionId}`);
            if (contributorsDiv && contributors.length > 0) {
                let html = '<h4 style="margin-top: 10px;">Individual Responses:</h4>';
                contributors.forEach(c => {
                    const isCurrentUser = c.username === currentUsername;
                    const badges = calculateBadges(c.username);
                    const badgeText = badges.length > 0 ? ` ${badges.join(' ')}` : '';

                    // CRITICAL: Always show the reason if it exists
                    html += `
                        <div class="contributor-item" style="${isCurrentUser ? 'background: #e3f2fd;' : ''}">
                            <span class="contributor-choice">${c.username}${badgeText} → Choice ${c.choice}</span>
                            ${c.reason ? `<div class="contributor-reason" style="margin-top: 5px; padding: 8px; background: #f9f9f9; border-left: 3px solid #2196F3; font-style: italic;">"${c.reason}"</div>` : '<div style="color: #999; font-style: italic; margin-top: 5px;">No explanation provided</div>'}
                        </div>
                    `;
                });
                contributorsDiv.innerHTML = html;
            }

            // ALSO populate the sidebar peer reasoning section
            populatePeerReasoning(questionId, contributors);
        }

        // Function to populate the sidebar peer reasoning section
        function populatePeerReasoning(questionId, contributors) {
            const peerReasoningContent = document.getElementById(`peer-reasoning-content-${questionId}`);
            const peerCount = document.getElementById(`peer-count-${questionId}`);

            if (!peerReasoningContent) return;

            // Update peer count
            if (peerCount) {
                const totalPeers = contributors.filter(c => c.username !== currentUsername).length;
                peerCount.textContent = `${totalPeers} peers`;
            }

            if (contributors.length === 0) {
                peerReasoningContent.innerHTML = '<div class="peer-hint">No peer responses available yet</div>';
                return;
            }

            // Filter out current user and sort by reasoning quality
            const peerResponses = contributors
                .filter(c => c.username !== currentUsername)
                .sort((a, b) => {
                    // Sort: those with reasons first, then alphabetically
                    if (a.reason && !b.reason) return -1;
                    if (!a.reason && b.reason) return 1;
                    return a.username.localeCompare(b.username);
                });

            if (peerResponses.length === 0) {
                peerReasoningContent.innerHTML = '<div class="peer-hint">You\'re the first to answer this question!</div>';
                return;
            }

            // Generate peer response cards
            let html = '';
            peerResponses.forEach(peer => {
                const badges = calculateBadges(peer.username);
                const badgeText = badges.length > 0 ? ` ${badges.join(' ')}` : '';
                const hasReason = peer.reason && peer.reason.trim().length > 0;

                // Determine if answer is correct (basic heuristic - could be enhanced)
                const isCorrect = badgeText.includes('🏆') || badgeText.includes('⭐');

                html += `
                    <div class="peer-response-card ${isCorrect ? 'correct' : 'incorrect'}">
                        <div class="peer-name">${peer.username}${badgeText}</div>
                        <div class="peer-answer"><strong>Answer:</strong> ${peer.choice || peer.response} ${isCorrect ? '✓' : ''}</div>
                        ${hasReason ?
                            `<div class="peer-reasoning-text">"${peer.reason}"</div>` :
                            '<div class="peer-reasoning-text" style="color: #999;">No explanation provided</div>'
                        }
                    </div>
                `;
            });

            peerReasoningContent.innerHTML = html;
        }

        // Render FRQ responses
        function renderFRQResponses(questionId) {
            const canvas = document.getElementById(`dotplot-${questionId}`);
            const consensusDiv = document.getElementById(`consensus-${questionId}`);
            const contributorsDiv = document.getElementById(`contributors-${questionId}`);
            
            if (canvas) canvas.style.display = 'none';
            
            const responses = [];
            for (let username in classData.users) {
                const userAnswer = classData.users[username].answers?.[questionId];
                if (userAnswer) {
                    const response = userAnswer.value || userAnswer;
                    const reason = classData.users[username].reasons?.[questionId] || '';
                    responses.push({
                        username: username,
                        response: response,
                        reason: reason
                    });
                }
            }
            
            if (consensusDiv) {
                if (responses.length > 1) {
                    consensusDiv.innerHTML = `
                        <div class="consensus-msg no-consensus">
                            ${responses.length} responses submitted. Review peer responses below.
                        </div>
                    `;
                } else {
                    consensusDiv.innerHTML = `
                        <div class="consensus-msg no-consensus">
                            Your response recorded. Import class data to see peer responses.
                        </div>
                    `;
                }
            }
            
            if (contributorsDiv) {
                let html = '<h4>Responses:</h4>';
                responses.forEach(r => {
                    const userVotes = classData.users[currentUsername]?.votes?.[questionId]?.[r.username] || {};
                    html += `
                        <div class="contributor-item">
                            <strong>${r.username}:</strong>
                            <div style="margin-top: 5px; padding: 10px; background: #f5f5f5; border-radius: 4px;">
                                ${r.response}
                            </div>
                            ${r.reason ? `<div class="contributor-reason">${r.reason}</div>` : ''}
                            <div style="margin-top: 10px;">
                                <button onclick="voteFRQ('${questionId}', '${r.username}', 'helpful')"
                                        class="vote-btn ${userVotes.type === 'helpful' ? 'active' : ''}">
                                    💡 Helpful (${getVoteCount(questionId, r.username, 'helpful')})
                                </button>
                                <button onclick="voteFRQ('${questionId}', '${r.username}', 'unclear')"
                                        class="vote-btn ${userVotes.type === 'unclear' ? 'active' : ''}">
                                    🤔 Unclear (${getVoteCount(questionId, r.username, 'unclear')})
                                </button>
                                <button onclick="voteFRQ('${questionId}', '${r.username}', 'contradicts')"
                                        class="vote-btn ${userVotes.type === 'contradicts' ? 'active' : ''}">
                                    ⚔️ Contradicts (${getVoteCount(questionId, r.username, 'contradicts')})
                                </button>
                            </div>
                        </div>
                    `;
                });
                contributorsDiv.innerHTML = html;
            }

            // ALSO populate the sidebar peer reasoning section for FRQ
            const frqContributors = responses.map(r => ({
                username: r.username,
                choice: 'FRQ Response',
                response: r.response,
                reason: r.reason
            }));
            populatePeerReasoning(questionId, frqContributors);
        }

        // Add explanation retroactively to enable retry
        window.addExplanationToRetry = function(questionId) {
            const reasonTextarea = document.getElementById(`reason-${questionId}`);
            const addExplanationBtn = document.getElementById(`add-explanation-${questionId}`);
            const submitBtn = document.getElementById(`submit-${questionId}`);
            const errorSpan = document.getElementById(`error-${questionId}`);
            const successSpan = document.getElementById(`success-${questionId}`);

            // Clear previous messages
            if (errorSpan) {
                errorSpan.textContent = '';
                errorSpan.classList.remove('show');
            }
            if (successSpan) {
                successSpan.textContent = '';
                successSpan.classList.remove('show');
            }

            // Check if explanation is provided
            const explanation = reasonTextarea ? reasonTextarea.value.trim() : '';
            if (!explanation) {
                if (errorSpan) {
                    errorSpan.textContent = 'Please provide an explanation first.';
                    errorSpan.classList.add('show');
                }
                // Focus on the textarea
                if (reasonTextarea) {
                    reasonTextarea.focus();
                    reasonTextarea.classList.add('required');
                }
                return;
            }

            // Save the explanation
            if (!classData.users[currentUsername]) {
                classData.users[currentUsername] = {
                    answers: {},
                    reasons: {},
                    timestamps: {},
                    attempts: {}
                };
            }

            classData.users[currentUsername].reasons[questionId] = explanation;
            saveClassData();

            // Update UI to enable retry
            if (addExplanationBtn) {
                addExplanationBtn.style.display = 'none';
            }

            if (submitBtn) {
                submitBtn.disabled = false;
                submitBtn.textContent = 'Update Answer';
            }

            // Re-enable form inputs for answer changes
            // Enable radio buttons for multiple choice
            const radioButtons = document.querySelectorAll(`input[name="choice-${questionId}"]`);
            radioButtons.forEach(radio => {
                radio.disabled = false;
            });

            // Enable FRQ textarea
            const frqTextarea = document.getElementById(`frq-${questionId}`);
            if (frqTextarea) {
                frqTextarea.disabled = false;
            }

            // Remove disabled styling from choice divs
            const choiceDivs = document.querySelectorAll(`[data-question-id="${questionId}"] .choice.disabled`);
            choiceDivs.forEach(choiceDiv => {
                choiceDiv.classList.remove('disabled');
            });

            // Show success message
            if (successSpan) {
                successSpan.textContent = 'Explanation added! You can now change your answer and retry.';
                successSpan.classList.add('show');
                setTimeout(() => {
                    successSpan.classList.remove('show');
                }, 4000);
            }

            // Remove required styling from textarea
            if (reasonTextarea) {
                reasonTextarea.classList.remove('required');
            }

            // Update placeholder text
            if (reasonTextarea) {
                reasonTextarea.placeholder = 'Explanation saved. You can now update your answer.';
            }
        }

        // Get correct answer from curriculum data
        function getCorrectAnswer(questionId) {
            // Find the question in the current questions array
            const question = currentQuestions.find(q => q.id === questionId);
            console.log(`DEBUG getCorrectAnswer: Question found:`, question);

            // Check for answerKey field (most common)
            if (question && question.answerKey) {
                console.log(`DEBUG getCorrectAnswer: Answer key found: "${question.answerKey}"`);
                return question.answerKey;
            }

            // Check for correct_answer field
            if (question && question.correct_answer) {
                console.log(`DEBUG getCorrectAnswer: Correct answer found: "${question.correct_answer}"`);
                return question.correct_answer;
            }

            // Check for answer field
            if (question && question.answer) {
                console.log(`DEBUG getCorrectAnswer: Answer field found: "${question.answer}"`);
                return question.answer;
            }

            console.log(`DEBUG getCorrectAnswer: No correct answer found for question ${questionId}`);
            return null;
        }

        // Get official explanation from curriculum data
        function getOfficialExplanation(questionId) {
            // Find the question in the current questions array
            const question = currentQuestions.find(q => q.id === questionId);
            console.log(`DEBUG getOfficialExplanation: Question found:`, question);

            // Check for various possible explanation field names
            if (question && question.explanation) {
                console.log(`DEBUG getOfficialExplanation: Explanation found: "${question.explanation}"`);
                return question.explanation;
            }

            if (question && question.rationale) {
                console.log(`DEBUG getOfficialExplanation: Rationale found: "${question.rationale}"`);
                return question.rationale;
            }

            if (question && question.solution) {
                console.log(`DEBUG getOfficialExplanation: Solution found: "${question.solution}"`);
                return question.solution;
            }

            if (question && question.reasoning) {
                console.log(`DEBUG getOfficialExplanation: Reasoning found: "${question.reasoning}"`);
                return question.reasoning;
            }

            // Check if attachments has explanation
            if (question && question.attachments && question.attachments.explanation) {
                console.log(`DEBUG getOfficialExplanation: Attachments explanation found: "${question.attachments.explanation}"`);
                return question.attachments.explanation;
            }

            console.log(`DEBUG getOfficialExplanation: No explanation found for question ${questionId}`);
            console.log(`DEBUG getOfficialExplanation: Available fields:`, Object.keys(question || {}));
            return null;
        }

        // Display College Board explanation below question (not in localStorage)
        function displayCollegeBoardExplanation(questionId) {
            console.log(`DEBUG: displayCollegeBoardExplanation called for ${questionId}`);

            const correctAnswer = getCorrectAnswer(questionId);
            const officialExplanation = getOfficialExplanation(questionId);

            console.log(`DEBUG: correctAnswer: ${correctAnswer}, officialExplanation: ${officialExplanation}`);

            if (correctAnswer) {
                // Find or create College Board explanation section
                let cbSection = document.getElementById(`college-board-explanation-${questionId}`);

                if (!cbSection) {
                    // Create the section below the answer key section
                    const answerKeySection = document.getElementById(`answer-key-${questionId}`);
                    if (answerKeySection) {
                        cbSection = document.createElement('div');
                        cbSection.id = `college-board-explanation-${questionId}`;
                        cbSection.className = 'college-board-explanation-section';
                        answerKeySection.parentNode.insertBefore(cbSection, answerKeySection.nextSibling);
                    }
                }

                if (cbSection) {
                    cbSection.style.display = 'block'; // Ensure it's visible for answer key detection
                    cbSection.innerHTML = `
                        <div class="college-board-content">
                            <h4>🏛️ College Board Official Explanation</h4>
                            <div class="cb-correct-answer">
                                <strong>Correct Answer:</strong> ${correctAnswer}
                            </div>
                            <div class="cb-official-explanation">
                                ${officialExplanation || 'Official explanation not available for this question. You got it right!'}
                            </div>
                        </div>
                    `;
                    cbSection.style.display = 'block';

                    // Change reasoning textarea border to gold
                    const reasonTextarea = document.getElementById(`reason-${questionId}`);
                    if (reasonTextarea) {
                        reasonTextarea.style.borderColor = '#f39c12';
                        reasonTextarea.style.boxShadow = '0 0 0 0.2rem rgba(243, 156, 18, 0.25)';
                    }

                    console.log(`DEBUG: College Board explanation displayed for ${questionId}`);

                    // Refresh peer responses to update correctness colors IMMEDIATELY
                    console.log(`DEBUG: About to refresh peer responses for color update`);
                    const question = currentQuestions.find(q => q.id === questionId);
                    if (question) {
                        // Add a small delay to ensure DOM is fully updated
                        setTimeout(() => {
                            populatePeerResponses(questionId, question.type);
                            console.log(`DEBUG: Peer responses refreshed for ${questionId} (after timeout)`);
                        }, 100);
                    } else {
                        console.log(`DEBUG: Question not found for refresh: ${questionId}`);
                    }
                }
            } else {
                console.log(`DEBUG: Missing data - correctAnswer: ${correctAnswer}, explanation: ${officialExplanation}`);
            }
        }

        // Display answer key with timer-based logic
        function displayAnswerKey(questionId, isCorrect, hasExplanation, attemptNumber) {
            const answerKeySection = document.getElementById(`answer-key-${questionId}`);
            const correctAnswerDiv = document.getElementById(`correct-answer-${questionId}`);
            const officialExplanationDiv = document.getElementById(`official-explanation-${questionId}`);

            if (!answerKeySection) return;

            // Clear any existing timers for this question
            if (window.answerKeyTimers && window.answerKeyTimers[questionId]) {
                clearTimeout(window.answerKeyTimers[questionId]);
                delete window.answerKeyTimers[questionId];
            }

            // Initialize timers object if needed
            if (!window.answerKeyTimers) {
                window.answerKeyTimers = {};
            }

            // Get correct answer and explanation
            const correctAnswer = getCorrectAnswer(questionId);
            const officialExplanation = getOfficialExplanation(questionId);

            // Populate answer key content (but we'll primarily show this in peer section now)
            if (correctAnswerDiv && correctAnswer) {
                correctAnswerDiv.innerHTML = `<strong>Correct Answer:</strong> ${correctAnswer}`;
            }

            if (officialExplanationDiv && officialExplanation) {
                officialExplanationDiv.innerHTML = `<strong>Official Explanation:</strong><br>${officialExplanation}`;
            }

            // Apply timer logic based on user's performance
            if (attemptNumber === 1) {
                // First attempt
                if (isCorrect && hasExplanation) {
                    // ✅ Correct + Explanation: Immediate answer key and College Board explanation
                    answerKeySection.style.display = 'block';
                    displayCollegeBoardExplanation(questionId);
                    console.log(`Answer key shown immediately: correct with explanation for ${questionId}`);
                } else if (isCorrect && !hasExplanation) {
                    // ⏰ Correct + No Explanation: 15-minute timer
                    console.log(`Starting 15-minute timer for ${questionId} (correct, no explanation)`);
                    window.answerKeyTimers[questionId] = setTimeout(() => {
                        answerKeySection.style.display = 'block';
                        displayCollegeBoardExplanation(questionId);
                        showMessage('Answer key revealed after 15 minutes (correct answer)', 'info');
                    }, 15 * 60 * 1000); // 15 minutes
                } else {
                    // ❌ Incorrect: No answer key until explanation provided or max attempts
                    console.log(`Answer key blocked for ${questionId} (incorrect answer)`);
                }
            } else if (attemptNumber === 2) {
                // Second attempt
                if (isCorrect && hasExplanation) {
                    // ✅ Correct on retry + Explanation: Immediate answer key and College Board explanation
                    answerKeySection.style.display = 'block';
                    displayCollegeBoardExplanation(questionId);
                    console.log(`Answer key shown immediately: correct on retry with explanation for ${questionId}`);
                } else if (isCorrect && !hasExplanation) {
                    // ⏰ Correct on retry + No Explanation: 15-minute timer
                    console.log(`Starting 15-minute timer for ${questionId} (correct on retry, no explanation)`);
                    window.answerKeyTimers[questionId] = setTimeout(() => {
                        answerKeySection.style.display = 'block';
                        displayCollegeBoardExplanation(questionId);
                        showMessage('Answer key revealed after 15 minutes (correct on retry)', 'info');
                    }, 15 * 60 * 1000); // 15 minutes
                }
            } else if (attemptNumber >= 3) {
                // Third attempt reached
                if (!isCorrect) {
                    // Still wrong after 3 attempts: 5-minute timer
                    console.log(`Starting 5-minute timer for ${questionId} (wrong after 3 attempts)`);
                    window.answerKeyTimers[questionId] = setTimeout(() => {
                        answerKeySection.style.display = 'block';
                        displayCollegeBoardExplanation(questionId);
                        showMessage('Answer key revealed after 5 minutes (3 incorrect attempts)', 'warning');
                    }, 5 * 60 * 1000); // 5 minutes
                } else if (hasExplanation) {
                    // ✅ Correct on retry + Explanation: Immediate answer key and College Board explanation
                    answerKeySection.style.display = 'block';
                    displayCollegeBoardExplanation(questionId);
                    console.log(`Answer key shown immediately: correct on retry with explanation for ${questionId}`);
                }
            }
        }

        // Function to show/hide answer key manually (for testing or override)
        function toggleAnswerKey(questionId, show = true) {
            const answerKeySection = document.getElementById(`answer-key-${questionId}`);
            if (answerKeySection) {
                answerKeySection.style.display = show ? 'block' : 'none';
            }
        }

        // Helper function to get vote count
        function getVoteCount(questionId, targetUser, voteType) {
            let count = 0;
            for (let username in classData.users) {
                const userVotes = classData.users[username].votes?.[questionId]?.[targetUser];
                if (userVotes?.type === voteType) {
                    count++;
                }
            }
            return count;
        }

        // Vote FRQ function
        window.voteFRQ = function(questionId, targetUser, voteType) {
            if (!classData.users[currentUsername].votes) {
                classData.users[currentUsername].votes = {};
            }
            if (!classData.users[currentUsername].votes[questionId]) {
                classData.users[currentUsername].votes[questionId] = {};
            }

            const existingVote = classData.users[currentUsername].votes[questionId][targetUser];
            if (existingVote?.type === voteType) {
                // Remove vote if clicking same button
                delete classData.users[currentUsername].votes[questionId][targetUser];
            } else {
                // Set new vote
                classData.users[currentUsername].votes[questionId][targetUser] = {
                    type: voteType,
                    timestamp: new Date().toISOString()
                };
            }

            saveClassData();
            renderFRQResponses(questionId);
        }

        // Load progress
        function loadProgress() {
            if (!currentUsername || !classData) return;

            // Add a counter for staggered rendering
            let renderDelay = 0;

            currentQuestions.forEach((question, index) => {
                const qId = question.id;
                const qContainer = document.querySelector(`[data-question-id="${qId}"]`);
                if (!qContainer) return;

                const isAnswered = isQuestionAnswered(qId);
                if (isAnswered) {
                    // Show dotplot with staggered delay to ensure proper rendering
                    const questionType = question.type;

                    // Use setTimeout with increasing delay for each question
                    setTimeout(() => {
                        // First ensure the dotplot section is visible
                        const dotplotSection = document.getElementById(`dotplot-section-${qId}`);
                        if (dotplotSection) {
                            dotplotSection.innerHTML = `
                                <canvas id="dotplot-${qId}" width="400" height="200"></canvas>
                                <div id="consensus-${qId}"></div>
                                <div class="contributors-list" id="contributors-${qId}"></div>
                            `;
                            dotplotSection.classList.add('show');
                            dotplotSection.style.opacity = '1';
                        }

                        // Now render the visualization
                        if (questionType === 'multiple-choice') {
                            renderMCQDistribution(qId);
                        } else {
                            renderFRQResponses(qId);
                        }
                    }, renderDelay);

                    // Increase delay for next question (100ms between each)
                    renderDelay += 100;

                    // Update button state
                    const submitBtn = document.getElementById(`submit-${qId}`);
                    if (submitBtn) {
                        if (!canRetry(qId)) {
                            submitBtn.textContent = 'Max Attempts Reached';
                            submitBtn.disabled = true;
                        } else {
                            submitBtn.textContent = 'Update Answer';
                        }
                    }
                }
            });
        }

        // ALTERNATE SOLUTION: If the above doesn't work, add this function to force refresh all visualizations:
        function refreshAllVisualizations() {
            // Call this after data import or when viewing past quizzes
            setTimeout(() => {
                currentQuestions.forEach((question, index) => {
                    const qId = question.id;
                    const isAnswered = isQuestionAnswered(qId);

                    if (isAnswered) {
                        setTimeout(() => {
                            const questionType = question.type;
                            if (questionType === 'multiple-choice') {
                                renderMCQDistribution(qId);
                            } else {
                                renderFRQResponses(qId);
                            }
                        }, index * 100); // Stagger by 100ms per question
                    }
                });
            }, 500); // Initial delay to ensure DOM is ready
        }

        // Export personal data
        // Export functions - moved to js/data_manager.js


        // Import class data
        window.importClassData = function(event) {
            console.log('=== importClassData called (sync modal) ===');
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    console.log('Sync modal - imported data:', importedData);
                    console.log('Sync modal - data keys:', Object.keys(importedData));

                    // Use the same detection logic as the main import
                    if (isMasterDataFile(importedData)) {
                        console.log('Sync modal - detected master database file');
                        importMasterData(importedData);
                        showMessage('✅ Master database imported successfully!', 'success');
                    } else if (importedData.exportType === 'master_database') {
                        console.log('Sync modal - legacy master database format');
                        mergeMasterData(importedData);
                    } else {
                        console.log('Sync modal - regular class data');
                        // Handle regular class data import (existing behavior)
                        mergeRegularClassData(importedData);
                    }

                } catch (error) {
                    console.error('Sync modal import error:', error);
                    showMessage('Error importing data: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
        }

        function mergeMasterData(masterData) {
            let updatedCount = 0;
            let preservedCount = 0;

            // Get current user's existing data
            let currentUserAnswers = JSON.parse(localStorage.getItem(`answers_${currentUsername}`) || '{}');
            // STANDARDIZATION FIX: Ensure existing data is also in standardized format
            currentUserAnswers = migrateAnswersToStandardFormat(currentUserAnswers);
            const currentUserProgress = JSON.parse(localStorage.getItem(`progress_${currentUsername}`) || '{}');

            // Merge class-wide data (consensus, etc.) - always take the master version for these
            if (masterData.classData) {
                localStorage.setItem('classData', JSON.stringify(masterData.classData));
            }
            if (masterData.consensusData) {
                localStorage.setItem('consensusResponses', JSON.stringify(masterData.consensusData));
            }

            // Import OTHER users' data completely (not the current user)
            if (masterData.allAnswers) {
                Object.keys(masterData.allAnswers).forEach(username => {
                    if (username !== currentUsername) {
                        // STANDARDIZATION FIX: Use migration function for other users' data
                        const standardizedAnswers = migrateAnswersToStandardFormat(masterData.allAnswers[username]);
                        localStorage.setItem(`answers_${username}`, JSON.stringify(standardizedAnswers));
                        updatedCount++;
                    }
                });
            }

            if (masterData.allProgress) {
                Object.keys(masterData.allProgress).forEach(username => {
                    if (username !== currentUsername) {
                        localStorage.setItem(`progress_${username}`, JSON.stringify(masterData.allProgress[username]));
                    }
                });
            }

            // For the CURRENT user, merge intelligently
            if (masterData.allAnswers && masterData.allAnswers[currentUsername]) {
                // STANDARDIZATION FIX: Standardize imported data first
                const standardizedImportedAnswers = migrateAnswersToStandardFormat(masterData.allAnswers[currentUsername]);
                const importedUserAnswers = standardizedImportedAnswers;

                // Merge answers - keep newer ones based on timestamp or attempt count
                Object.keys(importedUserAnswers).forEach(questionId => {
                    const importedAnswer = importedUserAnswers[questionId];
                    const currentAnswer = currentUserAnswers[questionId];

                    if (!currentAnswer) {
                        // No existing answer, take the imported one
                        currentUserAnswers[questionId] = importedAnswer;
                        updatedCount++;
                    } else {
                        // Compare and keep the better/newer one
                        // Option 1: Keep the one with more attempts (more work done)
                        if (importedAnswer.attempts && currentAnswer.attempts) {
                            if (importedAnswer.attempts > currentAnswer.attempts) {
                                currentUserAnswers[questionId] = importedAnswer;
                                updatedCount++;
                            } else {
                                preservedCount++;
                            }
                        }
                        // Option 2: Keep the one with a timestamp (if you have timestamps)
                        else if (importedAnswer.timestamp && currentAnswer.timestamp) {
                            if (new Date(importedAnswer.timestamp) > new Date(currentAnswer.timestamp)) {
                                currentUserAnswers[questionId] = importedAnswer;
                                updatedCount++;
                            } else {
                                preservedCount++;
                            }
                        }
                        // Option 3: Keep the one that's correct (if applicable)
                        else if (currentAnswer.correct) {
                            preservedCount++;
                        } else if (importedAnswer.correct) {
                            currentUserAnswers[questionId] = importedAnswer;
                            updatedCount++;
                        } else {
                            // Default: preserve current
                            preservedCount++;
                        }
                    }
                });

                // Save the merged answers
                localStorage.setItem(`answers_${currentUsername}`, JSON.stringify(currentUserAnswers));
            }

            // Merge progress similarly
            if (masterData.allProgress && masterData.allProgress[currentUsername]) {
                const importedProgress = masterData.allProgress[currentUsername];

                Object.keys(importedProgress).forEach(lessonId => {
                    if (!currentUserProgress[lessonId] ||
                        importedProgress[lessonId] > currentUserProgress[lessonId]) {
                        currentUserProgress[lessonId] = importedProgress[lessonId];
                    }
                });

                localStorage.setItem(`progress_${currentUsername}`, JSON.stringify(currentUserProgress));
            }

            // Import any other non-user-specific data from rawLocalStorage
            if (masterData.rawLocalStorage) {
                Object.keys(masterData.rawLocalStorage).forEach(key => {
                    // Skip user-specific data for current user
                    if (!key.includes(`_${currentUsername}`) &&
                        !key.startsWith('answers_') &&
                        !key.startsWith('progress_')) {

                        // Only import if it doesn't exist or is older
                        const existingData = localStorage.getItem(key);
                        if (!existingData) {
                            localStorage.setItem(key, masterData.rawLocalStorage[key]);
                        }
                    }
                });
            }

            showMessage(`Master data merged! Updated: ${updatedCount} items, Preserved your work: ${preservedCount} items`, 'success');

            // Reload to show the updated data
            setTimeout(() => location.reload(), 2000);
        }

        function mergeRegularClassData(importedData) {
            // Your existing import logic for regular class data
            // This handles non-master imports as before
            const classData = JSON.parse(localStorage.getItem('classData') || '{}');

            // Merge the imported data with existing...
            // [Your existing merge logic here]

            localStorage.setItem('classData', JSON.stringify(classData));
            showMessage('Class data imported successfully!', 'success');
            location.reload();
        }

        // Show message
        function showMessage(text, type) {
            const messageArea = document.getElementById('messageArea');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            messageDiv.textContent = text;
            
            messageArea.innerHTML = '';
            messageArea.appendChild(messageDiv);
            
            setTimeout(() => {
                messageDiv.style.opacity = '0';
                setTimeout(() => messageArea.innerHTML = '', 300);
            }, 5000);
        }

        // Theme management
        function initTheme() {
            const savedTheme = localStorage.getItem('quizTheme') || 'light';
            currentTheme = savedTheme;
            applyTheme(savedTheme);
        }

        function applyTheme(theme) {
            const body = document.body;
            const themeButton = document.querySelector('.theme-toggle');
            
            if (theme === 'dark') {
                body.classList.add('dark-theme');
                if (themeButton) themeButton.textContent = '☀️';
            } else {
                body.classList.remove('dark-theme');
                if (themeButton) themeButton.textContent = '🌙';
            }
            
            currentTheme = theme;
            localStorage.setItem('quizTheme', theme);
        }

        window.toggleTheme = function() {
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            applyTheme(newTheme);
        }


        // Initialize on load
        window.onload = function() {
            initTheme();
            
            // Check localStorage support
            if (!window.localStorage) {
                showMessage('Warning: LocalStorage is not available. Data will not be saved.', 'error');
            }
            
            promptUsername();
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Ctrl+S to export data
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                if (currentUsername) {
                    exportPersonal();
                }
            }
        });

        // Intersection Observer for lazy loading charts (optional enhancement)
        if ('IntersectionObserver' in window) {
            const chartObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const container = entry.target;
                        const chartId = container.dataset.chartId;
                        if (chartId && window.pendingCharts && window.pendingCharts[chartId]) {
                            renderChartNow(chartId);
                            delete window.pendingCharts[chartId];
                            chartObserver.unobserve(container);
                        }
                    }
                });
            }, {
                rootMargin: '100px'
            });
            
            // Observe chart containers when they're created
            window.observeChartContainers = function() {
                document.querySelectorAll('[data-chart-id]').forEach(container => {
                    chartObserver.observe(container);
                });
            }
        }

        // Helper function to check if an answer is correct
        function checkIfAnswerCorrect(questionId, peerAnswerValue) {
            try {
                if (typeof getCorrectAnswer === 'function') {
                    const correct = getCorrectAnswer(questionId);
                    if (correct == null || peerAnswerValue == null) return false;
                    return String(peerAnswerValue).trim().toLowerCase() === String(correct).trim().toLowerCase();
                }
                return false;
            } catch {
                return false;
            }
        }


        // Add this if it doesn't already exist
        if(!window.turboModeListenerAttached) {
            window.addEventListener('turboModeChanged', (e) => {
                if (!e.detail.enabled && window.spriteManager) {
                    window.spriteManager.clearAllPeerSprites();
                }
            });
            window.turboModeListenerAttached = true;
        }

        // Progress Tracking System
        function initializeProgressTracking() {
            if (!currentUsername) return;

            // Set session start time
            const now = new Date().toISOString();
            localStorage.setItem(`sessionStart_${currentUsername}`, now);

            // Clear any previous temporary progress markers
            localStorage.removeItem(`tempProgress_${currentUsername}`);

            console.log(`Progress tracking initialized for ${currentUsername} at ${now}`);

            // Check for import debug info from before page refresh
            const importDebug = localStorage.getItem('import_debug');
            if (importDebug) {
                const debugInfo = JSON.parse(importDebug);
                console.log('=== IMPORT DEBUG INFO (from before refresh) ===');
                console.log('Data keys:', debugInfo.dataKeys);
                console.log('Is personal file:', debugInfo.isPersonal);
                console.log('Is master file:', debugInfo.isMaster);
                console.log('Import timestamp:', debugInfo.timestamp);
                console.log('=== END IMPORT DEBUG ===');

                // Clear the debug info
                localStorage.removeItem('import_debug');
            }

            // Check for pending imports from before page refresh
            const pendingMaster = localStorage.getItem('pending_master_import');
            const pendingPersonal = localStorage.getItem('pending_personal_import');

            if (pendingMaster) {
                console.log('Processing pending master import...');
                try {
                    const data = JSON.parse(pendingMaster);
                    importMasterData(data);
                    console.log('✅ Master import completed after refresh');
                } catch (error) {
                    console.error('Error processing pending master import:', error);
                }
                localStorage.removeItem('pending_master_import');
            }

            if (pendingPersonal) {
                console.log('Processing pending personal import...');
                try {
                    const data = JSON.parse(pendingPersonal);
                    importPersonalData(data);
                    console.log('✅ Personal import completed after refresh');
                } catch (error) {
                    console.error('Error processing pending personal import:', error);
                }
                localStorage.removeItem('pending_personal_import');
            }
        }

        function markProgressAsUnsaved() {
            if (!currentUsername) return;
            localStorage.setItem(`tempProgress_${currentUsername}`, 'true');
            console.log(`Marked progress as unsaved for ${currentUsername}`);
        }

        function markProgressAsSaved() {
            if (!currentUsername) return;
            localStorage.removeItem(`tempProgress_${currentUsername}`);
            console.log(`Marked progress as saved for ${currentUsername}`);
        }

        function getProgressStatus() {
            if (!currentUsername) return { hasUnsavedProgress: false, sessionDuration: 0 };

            const sessionStart = localStorage.getItem(`sessionStart_${currentUsername}`);
            const tempProgress = localStorage.getItem(`tempProgress_${currentUsername}`);

            const sessionDuration = sessionStart ?
                (new Date() - new Date(sessionStart)) / 1000 / 60 : 0; // minutes

            return {
                hasUnsavedProgress: !!tempProgress,
                sessionDuration: sessionDuration,
                sessionStart: sessionStart
            };
        }

        // Enhanced answer saving that tracks progress
        function saveAnswerWithTracking(questionId, answer, options = {}) {
            if (!currentUsername) return;

            // Mark progress as unsaved when user makes changes
            markProgressAsUnsaved();

            // Call existing save answer function
            if (typeof saveAnswer === 'function') {
                saveAnswer(questionId, answer, options);
            }

            // Auto-save progress periodically
            clearTimeout(window.autoSaveTimeout);
            window.autoSaveTimeout = setTimeout(() => {
                markProgressAsSaved();
                console.log('Auto-saved progress');
            }, 30000); // 30 seconds delay
        }


    </script>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <script>




        // --- Main Event Listener for Real-Time Updates ---
        window.addEventListener('peer:answer', (event) => {
            const detail = event?.detail || {};

            // 1. Update the application's core state
            const stateWasUpdated = mergePeerAnswer(detail);

            if (stateWasUpdated) {
                // 2. If state was updated, handle sprite animation
                // (SpriteManager has its own internal turbo check via this.isTurboActive)
                if (window.spriteManager) {
                    const isCorrect = checkIfAnswerCorrect(detail.question_id, detail.answer_value);
                    window.spriteManager.handlePeerAnswer(detail.username, isCorrect);
                }

                // 3. Schedule the UI refresh for the quiz content
                requestAnimationFrame(() => {
                    refreshQuestionIfVisible(detail.question_id);
                    if (typeof updatePeerDataTimestamp === 'function') {
                        updatePeerDataTimestamp();
                    }
                });
            }
        });

        // New function to render unit selection menu
        function renderUnitMenu() {
            const questionsContainer = document.getElementById('questionsContainer');

            // Sort units numerically
            const sortedUnits = Object.keys(allCurriculumData).sort((a, b) => parseInt(a) - parseInt(b));

            console.log('Rendering units:', sortedUnits); // Debug log

            let unitsHtml = '';
            sortedUnits.forEach(unitNum => {
                const unitData = allCurriculumData[unitNum];
                const unitName = unitStructure[unitNum]?.name || `Unit ${unitNum}`;
                const lessonCount = unitData.unitInfo.lessonNumbers.length;
                const questionCount = unitData.questions.length;

                console.log(`Unit ${unitNum}: ${questionCount} questions, ${lessonCount} lessons`); // Debug log

                // Calculate completion percentage for this unit
                let completedQuestions = 0;
                unitData.questions.forEach(q => {
                    if (isQuestionAnswered(q.id)) completedQuestions++;
                });
                const completionPercent = questionCount > 0 ? Math.round((completedQuestions / questionCount) * 100) : 0;

                unitsHtml += `
                    <div class="unit-card" onclick="selectUnit(${unitNum})">
                        <div class="unit-header">
                            <h3>Unit ${unitNum}</h3>
                            <span class="completion-badge">${completionPercent}%</span>
                        </div>
                        <div class="unit-title">${unitName}</div>
                        <div class="unit-stats">
                            <span>${lessonCount} lessons</span>
                            <span>•</span>
                            <span>${questionCount} questions</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${completionPercent}%"></div>
                        </div>
                    </div>
                `;
            });

            questionsContainer.innerHTML = `
                <div class="curriculum-overview">
                    <h2>📚 AP Statistics Curriculum</h2>
                    <p style="text-align: center; color: #666;">Loaded ${sortedUnits.length} units</p>
                    <div class="units-grid">
                        ${unitsHtml}
                    </div>

                    <!-- Sync Modal -->

                </div>
            `;
        }

        // Function to select a unit
        window.selectUnit = function(unitNumber) {
            currentUnit = unitNumber;
            const unitData = allCurriculumData[unitNumber];
            allUnitQuestions = unitData.questions;

            // Render lesson selector for this unit
            renderLessonSelector(unitData.unitInfo);
        }

        // Modify backToUnits function to go back to unit menu instead
        window.backToUnits = function() {
            // Clear any existing charts
            Object.values(chartInstances).forEach(chart => {
                if (chart && typeof chart.destroy === 'function') {
                    chart.destroy();
                }
            });
            chartInstances = {};
            currentQuestions = [];
            currentUnit = null;
            currentLesson = null;

            // Show unit menu instead of file upload
            renderUnitMenu();
        }


        // Add this function to load resources from allUnitsData.js if it exists
        async function loadUnitResources() {
            try {
                // Check if ALL_UNITS_DATA exists (from allUnitsData.js)
                if (typeof ALL_UNITS_DATA !== 'undefined') {
                    console.log('Found ALL_UNITS_DATA, integrating resources...');
                    return ALL_UNITS_DATA;
                }

                // Try to dynamically load the file if not already loaded
                const script = document.createElement('script');
                script.src = 'allUnitsData.js';

                return new Promise((resolve, reject) => {
                    script.onload = () => {
                        if (typeof ALL_UNITS_DATA !== 'undefined') {
                            console.log('Loaded ALL_UNITS_DATA from file');
                            resolve(ALL_UNITS_DATA);
                        } else {
                            resolve(null);
                        }
                    };
                    script.onerror = () => resolve(null);
                    document.head.appendChild(script);
                });
            } catch (error) {
                console.log('No resources file found');
                return null;
            }
        }

        // Modified renderLessonSelector to show video resources
        async function renderLessonSelectorWithResources(unitInfo) {
            const questionsContainer = document.getElementById('questionsContainer');

            // Load resources if available
            const resources = await loadUnitResources();
            const unitResources = resources ?
                resources.find(u => u.unitId === `unit${currentUnit}`) : null;

            let lessonButtonsHtml = '';

            if (unitInfo && unitInfo.lessonNumbers) {
                unitInfo.lessonNumbers.forEach(lessonNum => {
                    const questions = unitInfo.lessons[lessonNum];
                    const isCompleted = questions.every(q => isQuestionAnswered(q.id));
                    const displayName = lessonNum === 'PC' ? 'Progress Check' : `Lesson ${lessonNum}`;
                    const buttonId = lessonNum === 'PC' ? 'lesson-btn-PC' : `lesson-btn-${lessonNum}`;

                    // Find matching resources for this lesson
                    let resourceInfo = '';
                    if (unitResources && lessonNum !== 'PC') {
                        const topicId = `${currentUnit}-${lessonNum}`;
                        const topic = unitResources.topics.find(t => t.id === topicId);
                        if (topic && topic.videos && topic.videos.length > 0) {
                            resourceInfo = `<span style="color: #4CAF50;">📹 ${topic.videos.length} video${topic.videos.length > 1 ? 's' : ''}</span>`;
                        }
                    }

                    lessonButtonsHtml += `
                        <button onclick="loadLesson('${lessonNum}')"
                                class="lesson-btn ${isCompleted ? 'completed' : ''}"
                                id="${buttonId}">
                            ${displayName}<br>
                            <small>${questions.length} questions</small>
                            ${resourceInfo ? `<br><small>${resourceInfo}</small>` : ''}
                        </button>
                    `;
                });

                questionsContainer.innerHTML = `
                    <button onclick="backToUnits()" class="back-button">← Back to Units</button>
                    <div class="lesson-selector">
                        <h3>Unit ${currentUnit}: ${unitStructure[currentUnit]?.name || 'Unknown Unit'}</h3>
                        <p>Select a lesson to begin:</p>
                        <div class="lesson-buttons">
                            ${lessonButtonsHtml}
                        </div>
                    </div>

                    <!-- Sync Modal -->
                `;
            }
        }

        // Modified loadLesson to show video resources at the top
        window.loadLessonWithResources = async function(lessonNumber) {
            currentLesson = lessonNumber;

            // Get questions for this lesson
            if (lessonNumber === 'PC') {
                currentQuestions = allUnitQuestions.filter(q => q.id.includes('-PC-'));
            } else {
                const lessonNum = parseInt(lessonNumber);
                currentQuestions = allUnitQuestions.filter(q => {
                    if (q.id.includes('-PC-')) return false;
                    const match = q.id.match(/U\d+-L(\d+)-/);
                    return match && parseInt(match[1]) === lessonNum;
                });
            }

            if (currentQuestions.length === 0) {
                showMessage(`No questions found for Lesson ${lessonNumber}`, 'error');
                return;
            }

            // Get resources for this lesson
            const resources = await loadUnitResources();
            let videoSection = '';

            if (resources && lessonNumber !== 'PC') {
                const unitResources = resources.find(u => u.unitId === `unit${currentUnit}`);
                if (unitResources) {
                    const topicId = `${currentUnit}-${lessonNumber}`;
                    const topic = unitResources.topics.find(t => t.id === topicId);

                    if (topic) {
                        videoSection = `
                            <div class="resources-section">
                                <h3>📚 Lesson Resources: ${topic.description}</h3>
                        `;

                        if (topic.videos && topic.videos.length > 0) {
                            videoSection += '<div class="video-resources">';
                            topic.videos.forEach((video, index) => {
                                videoSection += `
                                    <div class="video-item">
                                        <span class="video-number">Video ${index + 1}:</span>
                                        <a href="${video.url}" target="_blank" class="video-link">
                                            AP Classroom Video 📹
                                        </a>
                                        ${video.altUrl ? `
                                            <a href="${video.altUrl}" target="_blank" class="video-link alt">
                                                Alternative Link 🔗
                                            </a>
                                        ` : ''}
                                    </div>
                                `;
                            });
                            videoSection += '</div>';
                        }

                        videoSection += '</div>';
                    }
                }
            }

            // Render quiz with resources
            const questionsContainer = document.getElementById('questionsContainer');
            questionsContainer.innerHTML = `
                <button onclick="backToLessons()" class="back-button">← Back to Lessons</button>
                <div class="app-controls">
                    <div style="flex: 1;">
                        <strong>Unit ${currentUnit}, Lesson ${currentLesson}</strong> - ${currentQuestions.length} questions
                    </div>
                </div>

                ${videoSection}
                <div id="questions-list"></div>
                <div class="loading-msg" id="loading-msg" style="display:none;">Loading questions...</div>
            `;

            const questionsList = document.getElementById('questions-list');
            document.getElementById('loading-msg').style.display = 'block';

            setTimeout(() => {
                currentQuestions.forEach((question, index) => {
                    const questionHtml = renderQuestion(question, index);
                    questionsList.insertAdjacentHTML('beforeend', questionHtml);
                });

                document.getElementById('loading-msg').style.display = 'none';
                loadProgress();

                if (window.MathJax) {
                    MathJax.typesetPromise().catch(e => console.log('MathJax error:', e));
                }

                setTimeout(renderVisibleCharts, 100);
            }, 100);
        }

        // Add styles for the resources section
        const resourceStyles = `
        .resources-section {
            background: #f0f7ff;
            border: 2px solid #2196F3;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .resources-section h3 {
            margin-top: 0;
            color: #1976D2;
        }

        .video-resources {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 15px;
        }

        .video-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: white;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
        }

        .video-number {
            font-weight: bold;
            color: #666;
            min-width: 70px;
        }

        .video-link {
            padding: 6px 12px;
            background: #4CAF50;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            font-size: 14px;
            transition: background 0.3s;
        }

        .video-link:hover {
            background: #45a049;
        }

        .video-link.alt {
            background: #ff9800;
        }

        .video-link.alt:hover {
            background: #f57c00;
        }

        body.dark-theme .resources-section {
            background: #1e3a5f;
            border-color: #5BC0EB;
        }

        body.dark-theme .resources-section h3 {
            color: #5BC0EB;
        }

        body.dark-theme .video-item {
            background: #2d2d2d;
            border-color: #444;
        }

        /* Modal button styles */
        .sync-buttons .modal-btn {
            padding: 10px 20px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            justify-content: center;
        }

        .sync-buttons .modal-btn:hover {
            background: #1976D2;
        }

        .sync-buttons .modal-btn i {
            font-size: 16px;
        }
        `;

        // Add the styles
        document.head.insertAdjacentHTML('beforeend', `<style>${resourceStyles}</style>`);

        // Update the original functions to use the resource-aware versions
        window.renderLessonSelector = renderLessonSelectorWithResources;
        window.loadLesson = loadLessonWithResources;

        // Sync modal handlers
        window.openSyncModal = function() {
            const modal = document.getElementById('syncModal');
            if (modal) {
                modal.style.display = 'block';
            }
        }

        window.closeSyncModal = function() {
            const modal = document.getElementById('syncModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // Close modal when clicking outside or on close button
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('syncModal');
            if (event.target === modal || event.target.classList.contains('close-modal')) {
                closeSyncModal();
            }
        });

        // Tab switching functionality
        document.addEventListener('DOMContentLoaded', function() {
            // Handle tab clicks
            const tabs = document.querySelectorAll('.sync-tab');
            const tabContents = document.querySelectorAll('.sync-tab-content');

            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // Remove active class from all tabs and contents
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(tc => tc.classList.remove('active'));

                    // Add active class to clicked tab
                    tab.classList.add('active');

                    // Show corresponding content
                    const tabName = tab.getAttribute('data-tab');
                    if (tabName === 'local') {
                        document.getElementById('localSyncTab').classList.add('active');
                    } else if (tabName === 'cloud') {
                        document.getElementById('cloudSyncTab').classList.add('active');
                        // Update cloud sync stats when tab is opened
                        if (window.cloudSync) {
                            cloudSync.updateSyncStats();
                        }
                    }
                });
            });

            // Handle auto-sync toggle
            const autoSyncToggle = document.getElementById('autoSyncToggle');
            if (autoSyncToggle) {
                autoSyncToggle.addEventListener('change', function() {
                    if (window.cloudSync) {
                        cloudSync.toggleAutoSync();
                    }
                    document.getElementById('autoSyncStatus').textContent =
                        this.checked ? 'ON' : 'OFF';
                });
            }

            // Two-way sync button
            document.getElementById('syncBothWaysBtn')?.addEventListener('click', async function() {
                if (window.cloudSync) {
                    this.disabled = true;
                    this.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Syncing...';

                    try {
                        await cloudSync.pushToCloud();
                        setTimeout(async () => {
                            await cloudSync.pullFromCloud();
                            this.innerHTML = '<i class="fas fa-sync-alt"></i><span><strong>Two-Way Sync</strong><small>Merge local and cloud data</small></span>';
                            this.disabled = false;
                        }, 1000);
                    } catch (error) {
                        console.error('Two-way sync failed:', error);
                        this.innerHTML = '<i class="fas fa-sync-alt"></i><span><strong>Two-Way Sync</strong><small>Merge local and cloud data</small></span>';
                        this.disabled = false;
                    }
                }
            });
        });

        // Sync button functionality
        document.addEventListener('DOMContentLoaded', function() {

            // Handle Save button click (personal export)
            document.addEventListener('click', function(event) {
                if (event.target.id === 'saveBtn' || event.target.closest('#saveBtn')) {
                    exportPersonal();
                    closeSyncModal();
                }
            });

            // Handle Open button click (smart import)
            document.addEventListener('click', function(event) {
                if (event.target.id === 'openBtn' || event.target.closest('#openBtn')) {
                    // Create hidden file input for smart import
                    let smartImportInput = document.getElementById('smartImportFile');
                    if (!smartImportInput) {
                        smartImportInput = document.createElement('input');
                        smartImportInput.type = 'file';
                        smartImportInput.id = 'smartImportFile';
                        smartImportInput.accept = '.json';
                        smartImportInput.style.display = 'none';
                        smartImportInput.addEventListener('change', handleSmartImport);
                        document.body.appendChild(smartImportInput);
                    }
                    smartImportInput.click();
                    closeSyncModal();
                }
            });

            // Handle Master Import button click
            document.addEventListener('click', function(event) {
                if (event.target.id === 'masterImportBtn' || event.target.closest('#masterImportBtn')) {
                    event.preventDefault(); // Prevent any default behavior
                    event.stopPropagation(); // Stop event bubbling

                    console.log('=== Master Import button clicked ===');
                    // Create hidden file input for master import
                    let masterImportInput = document.getElementById('masterImportFile');
                    if (!masterImportInput) {
                        masterImportInput = document.createElement('input');
                        masterImportInput.type = 'file';
                        masterImportInput.accept = '.json';
                        masterImportInput.id = 'masterImportFile';
                        masterImportInput.style.display = 'none';
                        masterImportInput.addEventListener('change', function(fileEvent) {
                            fileEvent.preventDefault(); // Prevent any default behavior
                            console.log('Master import file selected');
                            const file = fileEvent.target.files[0];
                            if (!file) return;

                            // Reset the file input to allow re-selection of the same file
                            fileEvent.target.value = '';

                            const reader = new FileReader();
                            reader.onload = function(e) {
                                try {
                                    const data = JSON.parse(e.target.result);
                                    console.log('Master import - calling importMasterData with:', data);

                                    // Prevent ALL forms of page refresh/navigation
                                    window.onbeforeunload = function(e) {
                                        console.log('Preventing page refresh during import...');
                                        return 'Import in progress, are you sure you want to leave?';
                                    };

                                    // Capture and prevent any navigation
                                    const originalLocation = window.location.href;
                                    const preventNavigation = () => {
                                        if (window.location.href !== originalLocation) {
                                            window.location.href = originalLocation;
                                        }
                                    };
                                    const navInterval = setInterval(preventNavigation, 10);

                                    try {
                                        console.log('Starting direct localStorage import...');

                                        // Do the import directly here without calling any functions
                                        if (data && data.students) {
                                            const students = data.students;
                                            let importCount = 0;

                                            // Get or create classData structure for peer display
                                            const classData = JSON.parse(localStorage.getItem('classData') || '{}');
                                            if (!classData.users) classData.users = {};

                                            Object.entries(students).forEach(([username, userInfo]) => {
                                                if (userInfo.answers) {
                                                    // STANDARDIZATION FIX: Use migration function for consistency
                                                    const standardizedAnswers = migrateAnswersToStandardFormat(userInfo.answers);

                                                    // Store individual keys (for existing functionality)
                                                    localStorage.setItem(`answers_${username}`, JSON.stringify(standardizedAnswers));

                                                    // ALSO store in classData structure (for peer display)
                                                    if (!classData.users[username]) {
                                                        classData.users[username] = { answers: {}, reasons: {}, timestamps: {}, attempts: {} };
                                                    }
                                                    Object.assign(classData.users[username].answers, standardizedAnswers);

                                                    importCount++;
                                                }
                                                if (userInfo.progress) {
                                                    localStorage.setItem(`progress_${username}`, JSON.stringify(userInfo.progress));
                                                }
                                                if (userInfo.reasons) {
                                                    localStorage.setItem(`reasons_${username}`, JSON.stringify(userInfo.reasons));
                                                    Object.assign(classData.users[username].reasons, userInfo.reasons);
                                                }
                                                if (userInfo.timestamps) {
                                                    localStorage.setItem(`timestamps_${username}`, JSON.stringify(userInfo.timestamps));
                                                    Object.assign(classData.users[username].timestamps, userInfo.timestamps);
                                                }
                                                if (userInfo.attempts) {
                                                    localStorage.setItem(`attempts_${username}`, JSON.stringify(userInfo.attempts));
                                                    Object.assign(classData.users[username].attempts, userInfo.attempts);
                                                }
                                            });

                                            // Save the updated classData structure
                                            localStorage.setItem('classData', JSON.stringify(classData));

                                            // CRITICAL: Refresh the global classData variable
                                            window.classData = classData;

                                            // Also call initClassData to ensure everything is properly loaded
                                            if (typeof initClassData === 'function') {
                                                initClassData();
                                            }

                                            console.log(`Imported data for ${importCount} students`);
                                            console.log('Global classData updated:', window.classData);
                                            alert(`✅ Imported data for ${importCount} students! Peer answers should now be visible.`);
                                        } else {
                                            alert('❌ No students data found in file');
                                        }
                                    } catch (error) {
                                        console.error('Import failed:', error);
                                        alert('❌ Import failed: ' + error.message);
                                    } finally {
                                        // Clean up after import
                                        clearInterval(navInterval);
                                        window.onbeforeunload = null;
                                    }

                                } catch (error) {
                                    console.error('Master import error:', error);
                                    alert('❌ Error importing master database: ' + error.message);
                                }
                            };
                            reader.readAsText(file);
                        });
                        document.body.appendChild(masterImportInput);
                    }

                    // Use setTimeout to prevent any refresh issues
                    setTimeout(() => {
                        masterImportInput.click();
                    }, 50);

                    // Don't close modal immediately - let import complete first
                    setTimeout(() => {
                        closeSyncModal();
                    }, 200);
                }
            });

            // Handle Master Export button click
            document.addEventListener('click', function(event) {
                if (event.target.id === 'masterExportBtn' || event.target.closest('#masterExportBtn')) {
                    exportMasterData();
                    closeSyncModal();
                }
            });
        });
  // --- File Type Detection Functions ---

  /**
   * Detects if the imported data is a personal data file
   * Personal files have username and users object with the user's data
   */
   function isPersonalDataFile(data) {
      // Check for personal export format
      if (data.username && data.users && data.users[data.username]) {
          return true;
      }

      // Check for single user export with answers directly
      if (data.username && data.answers) {
          return true;
      }

      // Check if it has a single user in users object
      if (data.users && Object.keys(data.users).length === 1) {
          return true;
      }

      return false;
  }

  /**
   * Detects if the imported data is a master data file
   * Master files have multiple users or explicit master export type
   */
  function isMasterDataFile(data) {
      // Check for explicit master export type
      if (data.exportType === 'master_database') {
          return true;
      }

      // Check for multiple users
      if (data.users && Object.keys(data.users).length > 1) {
          return true;
      }

      // Check for master export format with allUsers
      if (data.allUsers && Array.isArray(data.allUsers)) {
          return true;
      }

      return false;
  }

  // --- End of File Type Detection Functions ---
        // Smart Import Function - Auto-detects file type
        function handleSmartImport(event) {
            console.log('handleSmartImport called', event);
            const file = event.target.files[0];
            console.log('Selected file:', file);
            if (!file) {
                console.log('No file selected');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    // Detect file type and handle appropriately
                    const debugInfo = {
                        dataKeys: Object.keys(data),
                        isPersonal: isPersonalDataFile(data),
                        isMaster: isMasterDataFile(data),
                        timestamp: new Date().toISOString()
                    };

                    // Store debug info to survive page refresh
                    localStorage.setItem('import_debug', JSON.stringify(debugInfo));
                    
                    console.log('File import debug - data keys:', Object.keys(data));

  // Direct detection logic without external functions
  let isPersonalFile = false;
  let isMasterFile = false;

  // Check for personal file formats
  if (data.username && data.users && data.users[data.username]) {
      // Standard personal export format
      isPersonalFile = true;
      console.log('Detected: Personal export format with username and users');
  } else if (data.username && data.answers) {
      // Alternative personal format with direct answers
      isPersonalFile = true;
      console.log('Detected: Personal format with direct answers');
  } else if (data.users && Object.keys(data.users).length === 1) {
      // Single user export
      isPersonalFile = true;
      console.log('Detected: Single user export format');
  } else if (data.users && Object.keys(data.users).length > 1) {
      // Multiple users - master file
      isMasterFile = true;
      console.log('Detected: Master file with multiple users');
  } else if (data.exportType === 'master_database') {
      // Explicit master export
      isMasterFile = true;
      console.log('Detected: Master database export');
  }

  console.log('File import debug - isPersonalFile:', isPersonalFile);
  console.log('File import debug - isMasterFile:', isMasterFile);

  // Process based on file type
  if (isPersonalFile) {
      console.log('Processing as personal data file...');
      importAndMergePersonalData(data);
      // Message is handled inside importAndMergePersonalData
      return;
  } else if (isMasterFile) {
      console.log('Processing as master data file...');
      importMasterData(data);
      showMessage('✅ Master data imported successfully!', 'success');
      return;
  } else {
      console.error('File structure does not match expected formats');
      console.log('Data sample:', JSON.stringify(data, null, 2).substring(0, 500) + '...');
      showMessage('⚠️ Unrecognized file format. Please check your file.', 'error');
  }

                    // Store the data temporarily to survive refresh
                    if (isMasterDataFile(data)) {
                        localStorage.setItem('pending_master_import', JSON.stringify(data));
                        console.log('Stored master data for import after refresh');
                    } else if (isPersonalDataFile(data)) {
                        localStorage.setItem('pending_personal_import', JSON.stringify(data));
                        console.log('Stored personal data for import after refresh');
                    }

                    // Prevent immediate actions that might cause refresh
                    setTimeout(() => {
                        if (isPersonalDataFile(data)) {
                            console.log('Detected: Personal data file');
                            importAndMergePersonalData(data);
  // Message is now handled inside importAndMergePersonalData for better feedback
                          } else if (isMasterDataFile(data)) {
                            console.log('Detected: Master database file');
                            importMasterData(data);
                            showMessage('✅ Master database imported successfully!', 'success');
                        } else {
                            console.log('File structure does not match expected formats');
                            console.log('Data sample:', JSON.stringify(data, null, 2).substring(0, 500));
                            showMessage('❌ Unrecognized file format. Please check your file.', 'error');
                        }
                    }, 500);
                } catch (error) {
                    console.error('Import error:', error);
                    showMessage('❌ Error reading file. Please check the file format.', 'error');
                }
            };
            reader.readAsText(file);
        }

        // File type detection functions
        function isPersonalDataFile(data) {
            // Personal data files typically have a single user's answers and progress
            return (data.answers && typeof data.answers === 'object') ||
                   (data.username && data.exportType === 'personal') ||
                   (data.progress && !data.students && !data.allUsers);
        }

        function isMasterDataFile(data) {
            // Master data files have multiple users or class-wide data
            return !!(data.students ||
                     data.allUsers ||
                     data.exportType === 'master_database' ||
                     (data.users && Object.keys(data.users).length > 1));
        }

        // Backward compatibility migration function
        function migrateAnswersToStandardFormat(answers) {
            const standardizedAnswers = {};
            const currentTime = Date.now();

            Object.entries(answers).forEach(([questionId, answer]) => {
                if (typeof answer === 'object' && answer.value !== undefined) {
                    // Already in new format
                    standardizedAnswers[questionId] = answer;
                } else {
                    // Convert from simple string format to object format
                    standardizedAnswers[questionId] = {
                        value: answer,
                        timestamp: currentTime
                    };
                }
            });

            return standardizedAnswers;
        }

        // Import functions for different file types
        function importPersonalData(data) {
            if (!currentUsername) {
                showMessage('❌ Please select a username first.', 'error');
                return;
            }

            // Import answers with standardization
            if (data.answers) {
                const standardizedAnswers = migrateAnswersToStandardFormat(data.answers);
                localStorage.setItem(`answers_${currentUsername}`, JSON.stringify(standardizedAnswers));
                console.log(`✓ Imported personal answers for ${currentUsername} (standardized format)`);
            }

            // Import progress
            if (data.progress) {
                localStorage.setItem(`progress_${currentUsername}`, JSON.stringify(data.progress));
            }

            // Reinitialize to show imported data
            initClassData();
            if (typeof renderUnitMenu === 'function') {
                renderUnitMenu();
            }
        }

        function importMasterData(data, targetUsername = null) {
            console.log('=== importMasterData called ===');
            console.log('Data passed to importMasterData:', data);
            console.log('Target username for restoration:', targetUsername);

            // Use existing master data import functionality
            if (typeof mergeMasterData === 'function') {
                console.log('Found mergeMasterData function, using it');
                mergeMasterData(data);
            } else {
                console.warn('No mergeMasterData function found, attempting basic import...');
                console.log('Import data structure:', data);
                console.log('Data keys:', Object.keys(data));
                console.log('Has students property:', !!data.students);
                console.log('Has allUsers property:', !!data.allUsers);
                console.log('Has users property:', !!data.users);

                // Try different possible structures
                let userData = null;
                if (data.students) {
                    userData = data.students;
                    console.log('Using data.students:', userData);
                } else if (data.allUsers) {
                    userData = data.allUsers;
                    console.log('Using data.allUsers:', userData);
                } else if (data.users) {
                    userData = data.users;
                    console.log('Using data.users:', userData);
                }

                if (userData) {
                    // Check if this is single-user restoration (from username screen)
                    if (targetUsername && userData[targetUsername]) {
                        console.log(`SINGLE-USER RESTORATION: Importing only data for ${targetUsername}`);
                        const userInfo = userData[targetUsername];

                        if (userInfo.answers) {
                            // STANDARDIZATION FIX: Use migration function for consistency
                            const standardizedAnswers = migrateAnswersToStandardFormat(userInfo.answers);
                            localStorage.setItem(`answers_${targetUsername}`, JSON.stringify(standardizedAnswers));
                            console.log(`✓ Restored answers for ${targetUsername} (standardized format)`);
                        }
                        if (userInfo.progress) {
                            localStorage.setItem(`progress_${targetUsername}`, JSON.stringify(userInfo.progress));
                            console.log(`✓ Restored progress for ${targetUsername}`);
                        }
                        if (userInfo.reasons) {
                            localStorage.setItem(`reasons_${targetUsername}`, JSON.stringify(userInfo.reasons));
                            console.log(`✓ Restored reasons for ${targetUsername}`);
                        }
                        if (userInfo.timestamps) {
                            localStorage.setItem(`timestamps_${targetUsername}`, JSON.stringify(userInfo.timestamps));
                            console.log(`✓ Restored timestamps for ${targetUsername}`);
                        }
                        if (userInfo.attempts) {
                            localStorage.setItem(`attempts_${targetUsername}`, JSON.stringify(userInfo.attempts));
                            console.log(`✓ Restored attempts for ${targetUsername}`);
                        }

                        console.log(`=== Single-user restoration completed for ${targetUsername} ===`);
                        return;
                    }

                    // Otherwise, do multi-user peer import
                    console.log('MULTI-USER PEER IMPORT: Importing data for', Object.keys(userData).length, 'students');
                    console.log('Student usernames:', Object.keys(userData));

                    // Get or create classData structure for peer display
                    const classData = JSON.parse(localStorage.getItem('classData') || '{}');
                    if (!classData.users) classData.users = {};

                    Object.entries(userData).forEach(([username, userInfo]) => {
                        console.log(`Processing user: ${username}`, userInfo);

                        if (userInfo.answers) {
                            // STANDARDIZATION FIX: Use migration function for consistency
                            const standardizedAnswers = migrateAnswersToStandardFormat(userInfo.answers);

                            // Store individual keys (for existing functionality)
                            const key = `answers_${username}`;
                            localStorage.setItem(key, JSON.stringify(standardizedAnswers));
                            console.log(`✓ Stored answers for ${username} in ${key} (standardized format)`);

                            // ALSO store in classData structure (for peer display)
                            if (!classData.users[username]) {
                                classData.users[username] = { answers: {}, reasons: {}, timestamps: {}, attempts: {} };
                            }
                            Object.assign(classData.users[username].answers, standardizedAnswers);
                            console.log(`✓ Added ${username} to classData structure`);
                        } else {
                            console.log(`⚠ No answers found for ${username}`);
                        }

                        if (userInfo.progress) {
                            const key = `progress_${username}`;
                            localStorage.setItem(key, JSON.stringify(userInfo.progress));
                            console.log(`✓ Stored progress for ${username} in ${key}`);
                        }

                        if (userInfo.reasons) {
                            localStorage.setItem(`reasons_${username}`, JSON.stringify(userInfo.reasons));
                            if (classData.users[username]) {
                                Object.assign(classData.users[username].reasons, userInfo.reasons);
                            }
                        }

                        if (userInfo.timestamps) {
                            localStorage.setItem(`timestamps_${username}`, JSON.stringify(userInfo.timestamps));
                            if (classData.users[username]) {
                                Object.assign(classData.users[username].timestamps, userInfo.timestamps);
                            }
                        }

                        if (userInfo.attempts) {
                            localStorage.setItem(`attempts_${username}`, JSON.stringify(userInfo.attempts));
                            if (classData.users[username]) {
                                Object.assign(classData.users[username].attempts, userInfo.attempts);
                            }
                        }
                    });

                    // Save the updated classData structure
                    localStorage.setItem('classData', JSON.stringify(classData));
                    console.log(`✓ Updated classData with ${Object.keys(classData.users).length} users`);

                    // CRITICAL: Refresh the global classData variable
                    window.classData = classData;

                    // Reinitialize to show imported data
                    if (typeof initClassData === 'function') {
                        console.log('Calling initClassData()');
                        initClassData();
                    }
                    if (typeof renderUnitMenu === 'function') {
                        console.log('Calling renderUnitMenu()');
                        renderUnitMenu();
                    }
                    console.log('=== Master data import completed ===');
                } else {
                    console.warn('❌ No students data found in import file');
                    console.log('Available data keys:', Object.keys(data));
                }
            }
        }

        // Update references from masterExportBtn to totalExportBtn
        window.exportMasterData = window.exportMasterData || function() {
            // Get ALL data from localStorage, not filtered by user
            const masterData = {
                exportTime: new Date().toISOString(),
                exportType: 'master_database',
                allUsers: Object.keys(localStorage)
                    .filter(key => key.includes('_username') || key.includes('answers_'))
                    .map(key => key.split('_')[1])
                    .filter((v, i, a) => a.indexOf(v) === i), // unique usernames

                // Get all class data without filtering
                classData: JSON.parse(localStorage.getItem('classData') || '{}'),

                // Get all answers from all users
                allAnswers: {},
                allProgress: {},

                // Include raw localStorage for complete backup
                rawLocalStorage: {}
            };

            // Collect all answers for all users
            Object.keys(localStorage).forEach(key => {
                if (key.startsWith('answers_')) {
                    const username = key.replace('answers_', '');
                    masterData.allAnswers[username] = JSON.parse(localStorage.getItem(key) || '{}');
                }
                if (key.startsWith('progress_')) {
                    const username = key.replace('progress_', '');
                    masterData.allProgress[username] = JSON.parse(localStorage.getItem(key) || '{}');
                }
                masterData.rawLocalStorage[key] = localStorage.getItem(key);
            });

            // Create and download the file
            const blob = new Blob([JSON.stringify(masterData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `master_database_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showMessage('Master database exported successfully!', 'success');
        }

        // Initialize sync functionality
        function initializeSyncModal() {
            // Update current user display
            const currentUserDisplay = document.getElementById('currentUserDisplay');
            if (currentUserDisplay) {
                currentUserDisplay.textContent = localStorage.getItem('consensusUsername') || 'Unknown';
            }

            // Show/hide turbo mode notice based on sync status
            const turboModeNotice = document.getElementById('turboModeNotice');
            if (turboModeNotice) {
                turboModeNotice.style.display = turboModeActive ? 'block' : 'none';
            }

            // Ensure Master Import button exists (add dynamically if missing)
            const masterExportBtn = document.getElementById('masterExportBtn');
            if (masterExportBtn && !document.getElementById('masterImportBtn')) {
                console.log('Master Import button missing, adding it dynamically');
                const masterImportBtn = document.createElement('button');
                masterImportBtn.id = 'masterImportBtn';
                masterImportBtn.className = 'modal-btn';
                masterImportBtn.innerHTML = `
                    <i class="fas fa-users"></i>
                    <span>
                        <strong>Import Class Data</strong>
                        <small>Load peer answers from teacher's file</small>
                    </span>
                `;
                masterExportBtn.parentNode.appendChild(masterImportBtn);
                console.log('Master Import button added dynamically');
            }
        }

        // Show sync modal
        function showSyncModal() {
            initializeSyncModal();

            const modal = document.getElementById('syncModal');
            if (modal) {
                modal.style.display = 'block';

                // Debug: Check if Master Import button exists and add if missing
                setTimeout(() => {
                    let masterImportBtn = document.getElementById('masterImportBtn');
                    console.log('Master Import button exists:', !!masterImportBtn);

                    if (masterImportBtn) {
                        console.log('Master Import button element:', masterImportBtn);
                    } else {
                        console.error('Master Import button NOT FOUND in DOM!');
                        console.log('All buttons in modal:', modal.querySelectorAll('button'));

                        // Force add the button
                        const masterExportBtn = document.getElementById('masterExportBtn');
                        if (masterExportBtn) {
                            console.log('Adding Master Import button manually...');
                            masterImportBtn = document.createElement('button');
                            masterImportBtn.id = 'masterImportBtn';
                            masterImportBtn.className = 'modal-btn';
                            masterImportBtn.innerHTML = `
                                <i class="fas fa-cloud-download-alt"></i>
                                <span>
                                    <strong>Master Import</strong>
                                    <small>Import peer data from master database</small>
                                </span>
                            `;
                            masterExportBtn.parentNode.appendChild(masterImportBtn);
                            console.log('Master Import button added manually!');
                        }
                    }
                }, 100);
            } else {
                console.error('Sync modal element not found!');
                // Fallback: try to find any modal with sync-related content
                const allModals = document.querySelectorAll('.modal');
                console.log('Available modals:', allModals);
            }
        }


        // Runtime migration function to update existing localStorage data
        function migrateExistingAnswersData() {
            console.log('Checking for existing answers data that needs migration...');
            let migrationCount = 0;

            Object.keys(localStorage).forEach(key => {
                if (key.startsWith('answers_')) {
                    try {
                        const answers = JSON.parse(localStorage.getItem(key));
                        let needsMigration = false;

                        // Check if any answers are still in simple string format
                        for (const questionId in answers) {
                            if (typeof answers[questionId] !== 'object' || answers[questionId].value === undefined) {
                                needsMigration = true;
                                break;
                            }
                        }

                        if (needsMigration) {
                            const standardizedAnswers = migrateAnswersToStandardFormat(answers);
                            localStorage.setItem(key, JSON.stringify(standardizedAnswers));
                            migrationCount++;
                            console.log(`✓ Migrated ${key} to standardized format`);
                        }
                    } catch (error) {
                        console.error(`Error migrating ${key}:`, error);
                    }
                }
            });

            if (migrationCount > 0) {
                console.log(`✅ Migrated ${migrationCount} answer datasets to standardized format`);
            } else {
                console.log('✅ All existing answer data is already in standardized format');
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Run migration on existing data
            migrateExistingAnswersData();

            // Initialize turbo mode (Supabase sync)
            initializeTurboMode().then(() => {
                console.log('Turbo mode initialization complete');
            }).catch(error => {
                console.log('Turbo mode initialization error:', error);
            });

            // Set up sync button
            const syncBtn = document.getElementById('syncBtn');
            if (syncBtn) {
                syncBtn.addEventListener('click', showSyncModal);
            }

            // Set up share modal event listeners
            const shareModal = document.getElementById('shareModal');
            if (shareModal) {
                // Close modal when clicking outside
                window.addEventListener('click', function(event) {
                    if (event.target === shareModal) {
                        closeShareModal();
                    }
                });

                // Close modal with ESC key
                document.addEventListener('keydown', function(event) {
                    if (event.key === 'Escape' && shareModal.style.display === 'block') {
                        closeShareModal();
                    }
                });
            }

            // Check for initial page load and add share info
            const questionsContainer = document.getElementById('questionsContainer');
            if (questionsContainer) {
                // Check if we're on initial/username page
                const currentUsername = localStorage.getItem('consensusUsername');
                if (!currentUsername) {
                    // Add share button to initial page
                    const shareHtml = `
                        <div style="text-align: center; margin: 30px 0;">
                            <h2>Welcome to AP Stats Consensus Quiz!</h2>
                            <p style="margin: 15px 0;">A collaborative learning platform for AP Statistics</p>
                            <button onclick="showShareModal()" style="
                                background: #9b59b6;
                                color: white;
                                border: none;
                                padding: 15px 30px;
                                border-radius: 8px;
                                font-size: 18px;
                                cursor: pointer;
                                margin: 20px 10px;
                                transition: all 0.3s ease;
                            " onmouseover="this.style.background='#8e44ad'" onmouseout="this.style.background='#9b59b6'">
                                📤 Share This App
                            </button>
                            <p style="margin-top: 20px; color: #666;">
                                <small>New to this app? Click the share button to learn more!</small>
                            </p>
                        </div>
                    `;
                    questionsContainer.innerHTML = shareHtml + questionsContainer.innerHTML;
                }
            }
        });

    </script>

    <!-- Sprite Configuration Modal -->
    <div id="spriteConfigModal" class="modal" style="display: none;">
        <div class="modal-content">
            <span class="close-modal" onclick="closeSpriteConfigModal()">&times;</span>
            <h2>🎮 Sprite Configuration</h2>

            <div class="sprite-config-section">
                <h3>Enable Sprites</h3>
                <label class="switch">
                    <input type="checkbox" id="spritesEnabledToggle" checked>
                    <span class="slider round"></span>
                </label>
            </div>

            <div class="sprite-config-section">
                <h3>Sprite Color</h3>
                <div class="color-picker">
                    <label for="spriteHueSlider">Hue: <span id="hueValue">0</span>°</label>
                    <input type="range" id="spriteHueSlider" min="0" max="360" value="0" step="1">
                    <div class="color-preview">
                        <div id="spriteColorPreview" style="width: 50px; height: 50px; border-radius: 5px; margin: 10px 0;"></div>
                    </div>
                </div>

                <div class="sprite-preview-section">
                    <h4>Preview</h4>
                    <canvas id="spritePreviewCanvas" width="100" height="100" style="border: 1px solid #ccc; border-radius: 5px;"></canvas>
                </div>
            </div>

            <div class="modal-buttons">
                <button class="modal-btn save-btn" onclick="saveSpriteConfig()">Save Settings</button>
                <button class="modal-btn cancel-btn" onclick="closeSpriteConfigModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Canvas System Scripts -->
    <script src="js/sprite_sheet.js"></script>
    <script src="js/canvas_engine.js"></script>
    <script src="js/entities/player_sprite.js"></script>
    <script src="js/entities/peer_sprite.js"></script>
    <script src="js/sprite_manager.js"></script>

    <script>
        // Sprite system globals
        let canvasEngine, playerSprite, spriteSheet, spriteManager;

        // Initialize sprite system
        document.addEventListener('DOMContentLoaded', () => {
            canvasEngine = new CanvasEngine('spriteCanvas');

            // Load sprite sheet with correct dimensions (80x96 pixels per frame)
            spriteSheet = new SpriteSheet('sprite.png', 80, 96, {
                columns: 11,
                rows: 2,
                paddingX: 4,
                paddingY: 4
            });

            // Create player sprite
            playerSprite = new PlayerSprite(spriteSheet, 100, canvasEngine.groundY - 96);
            canvasEngine.addEntity('player', playerSprite);

            // Create sprite manager
            spriteManager = new SpriteManager(canvasEngine, spriteSheet);
            window.spriteManager = spriteManager; // Expose globally for early listeners

            // Check if sprites are enabled
            const spritesEnabled = localStorage.getItem('spritesEnabled') !== 'false';
            if (spritesEnabled) {
                canvasEngine.start();
            }
        });

        // Sprite configuration modal functions
        function showSpriteConfigModal() {
            const modal = document.getElementById('spriteConfigModal');
            if (!modal) return;

            modal.style.display = 'block';

            // Load current settings
            const spritesEnabled = localStorage.getItem('spritesEnabled') !== 'false';
            const hue = parseInt(localStorage.getItem('spriteColorHue') || '0', 10);

            document.getElementById('spritesEnabledToggle').checked = spritesEnabled;
            document.getElementById('spriteHueSlider').value = hue;

            updateSpriteConfigPreview();
        }

        function closeSpriteConfigModal() {
            const modal = document.getElementById('spriteConfigModal');
            if (modal) modal.style.display = 'none';
        }

        function updateSpriteConfigPreview() {
            const hue = document.getElementById('spriteHueSlider').value;
            document.getElementById('hueValue').textContent = hue;

            const preview = document.getElementById('spriteColorPreview');
            preview.style.backgroundColor = `hsl(${hue}, 70%, 50%)`;

            const canvas = document.getElementById('spritePreviewCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (spriteSheet && spriteSheet.loaded) {
                ctx.save();
                ctx.filter = `hue-rotate(${hue}deg)`;
                // Draw frame 0 centered in preview canvas
                spriteSheet.drawFrame(ctx, 0, 10, 2, 1, 0);
                ctx.restore();
            }
        }

        function saveSpriteConfig() {
            const spritesEnabled = document.getElementById('spritesEnabledToggle').checked;
            const hue = parseInt(document.getElementById('spriteHueSlider').value, 10);

            localStorage.setItem('spritesEnabled', spritesEnabled.toString());
            localStorage.setItem('spriteColorHue', hue.toString());

            // Apply settings
            if (playerSprite) {
                playerSprite.setHue(hue);
            }

            if (spritesEnabled) {
                if (canvasEngine && !canvasEngine.running) {
                    canvasEngine.start();
                }
            } else {
                if (canvasEngine && canvasEngine.running) {
                    canvasEngine.stop();
                }
            }

            closeSpriteConfigModal();
        }

        // Listen for hue slider changes
        document.addEventListener('DOMContentLoaded', () => {
            const slider = document.getElementById('spriteHueSlider');
            if (slider) {
                slider.addEventListener('input', updateSpriteConfigPreview);
            }
        });


        // Clear peer sprites when turbo mode is disabled
        window.addEventListener('turboModeChanged', (e) => {
            if (!e.detail.enabled && spriteManager) {
                spriteManager.clearAllPeerSprites();
            }
        });

    </script>
</body>
</html>
